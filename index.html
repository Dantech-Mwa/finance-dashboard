<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JDGlobal Markets</title>
  <meta name="description" content="Advanced finance dashboard with candlestick charts, indicators, trade advisories, crypto/forex signals and news thumbnails." />

  <!-- Chart.js + Financial plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.0/dist/chartjs-chart-financial.min.js"></script>
  <!-- Zoom & Pan plugin for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    html, body { height: 100%; }
    body { font-family: Inter, "Segoe UI", Roboto, Arial, sans-serif; background: #f6f8fb; color: #0b2240; margin: 0; padding: 18px; }
    #app { max-width: 1200px; margin: 0 auto; background: #fff; border-radius: 12px; padding: 18px; border: 1px solid #e6eef6; box-shadow: 0 12px 40px rgba(13,30,50,0.06); }
    .grid-main { display: grid; grid-template-columns: 320px 1fr; gap: 18px; margin-top: 16px; align-items: start; }
    @media (max-width: 700px) and (min-width: 421px) {
      .grid-main { grid-template-columns: 1fr 300px; gap: 12px; }
      .left { order: 2; }
      .mainSection { order: 1; }
      .chartWrap { height: 300px !important; }
      canvas#ohlcChart { height: 300px !important; }
    }
    @media (max-width: 420px) {
      .grid-main { grid-template-columns: minmax(140px, 1fr) 160px; gap: 8px; }
      .left { order: 2; }
      .mainSection { order: 1; }
      .chartWrap { height: 220px !important; }
      canvas#ohlcChart { height: 220px !important; }
      #app { overflow-x: auto; }
    }
    .card { background: #fff; border: 1px solid #eef6fb; border-radius: 10px; padding: 12px; }
    .chartWrap { height: 420px; position: relative; }
    .newsGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 12px; }
    .postsGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 12px; }
    .meta { color: #6b7b8c; }
    .loading { opacity: 0.6; }
    .pulse { animation: pulse 1.5s infinite; }
    @keyframes pulse { 0%{opacity:1} 50%{opacity:0.5} 100%{opacity:1} }
    canvas#ohlcChart { width: 100% !important; display: block; }
    .card-border { border: 1px solid #e6eef6; }
    .zoom-slider { width: 180px; }
    .ws-status { font-size: 0.75rem; color: #6b7b8c; }
    .ws-status.connected { color: #00cc00; }
    .ws-status.disconnected { color: #d32f2f; }
  </style>
</head>
<body>
  <div id="app">
    <div class="header flex items-center justify-between pb-3 border-b border-slate-100">
      <div class="flex items-center gap-4">
        <div class="w-14 h-14 rounded-xl bg-gradient-to-br from-sky-50 to-white flex items-center justify-center text-sky-600 font-extrabold text-lg shadow-sm">JDG</div>
        <div>
          <div class="text-lg font-semibold">JDGlobal Markets</div>
          <div class="text-sm meta">Real-time candlesticks, indicators, trade advisories & market news</div>
        </div>
      </div>
      <div class="flex items-center gap-3">
        <input id="globalSearch" placeholder="Symbol e.g. AAPL, TSLA, BTC, EURUSD" class="px-3 py-2 rounded-lg border card-border text-sm focus:outline-none" />
        <button id="loadBtn" class="px-3 py-2 rounded-lg bg-sky-600 text-white text-sm hover:bg-sky-700">Load</button>
      </div>
    </div>

    <main class="grid-main">
      <aside class="left flex flex-col gap-4">
        <div class="card">
          <h4>Watchlist</h4>
          <div id="watchlist">Loading…</div>
          <div class="mt-2"><small class="meta">Tip: Add any global ticker (US/EU/Asia). For forex use EURUSD, for crypto use BTC, ETH etc.</small></div>
        </div>
        <div class="card">
          <h4>Trade Advisories</h4>
          <div id="advisories" class="advice">Loading advisories…</div>
        </div>
        <div class="card">
          <h4>Crypto Suggestions</h4>
          <div id="cryptoAdvice" class="advice">Loading crypto suggestions…</div>
        </div>
      </aside>
      <section class="mainSection">
        <div class="card chartCard">
          <div class="chartToolbar flex items-center gap-3 flex-wrap">
            <div><strong id="chartTitle">Select a symbol</strong></div>
            <div style="margin-left:auto" class="meta">Updated: <span id="chartUpdated">—</span></div>
            <div class="ws-status" id="wsStatus">WebSocket: Connecting...</div>
            <div id="timeRange" class="flex gap-2"></div>
            <div id="chartType" class="flex gap-2"></div>
            <select id="indicatorSelect" class="indicatorSelect ml-2 px-3 py-1 border rounded-lg card-border text-sm">
              <option value="none">MA: None</option>
              <option value="ma10">MA10</option>
              <option value="ma20">MA20</option>
              <option value="ma50">MA50</option>
            </select>
            <div class="ml-2 flex items-center gap-2">
              <label class="text-xs meta">Zoom</label>
              <input id="zoomSlider" class="zoom-slider" type="range" min="1" max="100" value="100" />
            </div>
          </div>
          <div class="chartWrap mt-3 rounded-lg overflow-hidden bg-slate-50 p-3">
            <canvas id="ohlcChart" aria-label="OHLC candlestick chart"></canvas>
          </div>
          <div style="margin-top:12px">
            <strong>Market News</strong>
            <div class="newsGrid" id="newsGrid">Loading news…</div>
          </div>
        </div>
        <div class="card mt-3">
          <h4 style="margin-top:0">Market Watch Posts</h4>
          <div class="postsGrid" id="postsArea">Loading posts…</div>
        </div>
      </section>
    </main>

    <footer class="mt-5 pt-4 border-t border-slate-100 flex flex-col md:flex-row items-start justify-between gap-4">
      <div>
        <div class="font-semibold">Market Pulse</div>
        <div class="meta">Real Markets Data and Analysis Dashboard by JDG Team</div>
      </div>
      <div class="contact card" style="width:360px">
        <strong>Contact</strong>
        <div class="meta">Messages will be prepared for: <strong>wambuamwanza6@gmail.com</strong></div>
        <input id="name" placeholder="Your name" class="mt-3 px-3 py-2 w-full rounded-lg border card-border text-sm" />
        <input id="email" placeholder="Your email" class="mt-2 px-3 py-2 w-full rounded-lg border card-border text-sm" />
        <textarea id="message" rows="4" placeholder="Your message" class="mt-2 px-3 py-2 w-full rounded-lg border card-border text-sm"></textarea>
        <button id="sendBtn" class="mt-3 px-4 py-2 rounded-lg bg-sky-600 text-white text-sm hover:bg-sky-700">Send</button>
        <div id="sendStatus" class="meta mt-2 text-sm"></div>
      </div>
    </footer>
  </div>

  <script>
    const ALPHA_VANTAGE_API_KEY = 'INZ7GV3B33PXV2QM';
    let lastNewsUpdate = 0;
    let lastCryptoUpdate = 0;
    const NEWS_UPDATE_INTERVAL = 300000;
    const CRYPTO_UPDATE_INTERVAL = 60000;
    let currentSymbol = '';
    let currentRange = '1D';
    let currentChartType = 'candlestick';
    let currentIndicator = 'none';
    let ohlcChart = null;
    let binanceWS = null;
    let currentBucket = null;
    let liveLineBuffer = [];
    const MAX_POINTS = 60; // 60 seconds of data
    const LIVE_LINE_MAX = 300; // 5 minutes for live line overlay
    let useFallbackData = false;

    const $ = id => document.getElementById(id);
    const dataCache = new Map();
    const CACHE_DURATION = 60000;

    function getWatch() {
      try { return JSON.parse(localStorage.getItem('mp_watch') || '["AAPL","MSFT","GOOGL","TSLA","BTC"]'); }
      catch (e) { return ['AAPL','MSFT','GOOGL','TSLA','BTC']; }
    }
    function saveWatch(a) { localStorage.setItem('mp_watch', JSON.stringify(a)); }

    function updateWebSocketStatus(status, error = '') {
      const wsStatusEl = $('wsStatus');
      if (status === 'connected') {
        wsStatusEl.textContent = 'WebSocket: Connected';
        wsStatusEl.classList.remove('disconnected');
        wsStatusEl.classList.add('connected');
      } else if (status === 'disconnected') {
        wsStatusEl.textContent = `WebSocket: Disconnected${error ? ' - ' + error : ''}`;
        wsStatusEl.classList.remove('connected');
        wsStatusEl.classList.add('disconnected');
      } else {
        wsStatusEl.textContent = `WebSocket: ${status}${error ? ' - ' + error : ''}`;
        wsStatusEl.classList.remove('connected', 'disconnected');
      }
    }

    // Live WebSocket: per-trade stream, per-second candle bucketing
    function connectBinance(symbol) {
      if (!symbol) return;
      if (binanceWS) try { binanceWS.close(); } catch(e) {}
      const lower = symbol.toLowerCase();
      const url = `wss://stream.binance.com:9443/ws/${lower}@trade`;
      try {
        binanceWS = new WebSocket(url);
        updateWebSocketStatus('Connecting...');
      } catch (e) {
        console.error('WS connect error', e);
        updateWebSocketStatus('disconnected', 'Connection failed');
        useFallbackData = true;
        startFallbackData(symbol);
        return;
      }

      binanceWS.onopen = () => {
        console.log('Binance WS open for', symbol);
        updateWebSocketStatus('connected');
        useFallbackData = false;
        stopFallbackData();
      };

      binanceWS.onmessage = (evt) => {
        try {
          const msg = JSON.parse(evt.data);
          const price = parseFloat(msg.p);
          const ts = msg.T || Date.now();
          handleLiveTick(price, ts);
        } catch (e) {
          console.error('WS message error', e);
        }
      };

      binanceWS.onerror = (err) => {
        console.error('Binance WS error', err);
        updateWebSocketStatus('disconnected', 'Connection error');
      };

      binanceWS.onclose = () => {
        console.warn('Binance WS closed; reconnecting in 2s');
        updateWebSocketStatus('disconnected', 'Reconnecting...');
        setTimeout(() => connectBinance(symbol), 2000);
      };
    }

    function handleLiveTick(price, ts) {
      if (!ohlcChart || !currentSymbol) return;
      const sec = Math.floor(ts / 1000) * 1000;
      if (!currentBucket || currentBucket.t !== sec) {
        currentBucket = { t: sec, o: price, h: price, l: price, c: price };
        if (currentChartType === 'candlestick') {
          const ds = ohlcChart.data.datasets.find(d => d.type === 'candlestick');
          if (ds) {
            ds.data.push({ x: currentBucket.t, o: currentBucket.o, h: currentBucket.h, l: currentBucket.l, c: currentBucket.c });
            if (ds.data.length > MAX_POINTS) ds.data.shift();
          } else {
            const d0 = ohlcChart.data.datasets[0];
            d0.data.push({ x: ts, y: price });
            if (d0.data.length > MAX_POINTS) d0.data.shift();
          }
        } else {
          const d0 = ohlcChart.data.datasets[0] || (ohlcChart.data.datasets[0] = { 
            label: currentSymbol, 
            data: [], 
            type: currentChartType, 
            borderColor: '#0b76d1', 
            backgroundColor: currentChartType === 'bar' ? 'rgba(11,118,209,0.6)' : 'rgba(11,118,209,0.1)', 
            fill: currentChartType !== 'bar', 
            tension: 0.4, 
            pointRadius: 0, 
            borderWidth: 2 
          });
          d0.data.push({ x: ts, y: price });
          if (d0.data.length > MAX_POINTS) d0.data.shift();
        }
      } else {
        currentBucket.h = Math.max(currentBucket.h, price);
        currentBucket.l = Math.min(currentBucket.l, price);
        currentBucket.c = price;
        if (currentChartType === 'candlestick') {
          const ds = ohlcChart.data.datasets.find(d => d.type === 'candlestick');
          if (ds && ds.data.length) {
            const last = ds.data[ds.data.length - 1];
            last.h = Math.max(last.h, price);
            last.l = Math.min(last.l, price);
            last.c = price;
          }
        } else {
          const d0 = ohlcChart.data.datasets[0];
          if (d0 && d0.data.length) d0.data[d0.data.length - 1].y = price;
        }
      }

      liveLineBuffer.push({ x: ts, y: price });
      if (liveLineBuffer.length > LIVE_LINE_MAX) liveLineBuffer.shift();

      const liveLabel = `LIVE: ${currentSymbol}`;
      let liveIdx = ohlcChart.data.datasets.findIndex(d => d.label === liveLabel);
      const livePoints = liveLineBuffer.slice(-LIVE_LINE_MAX);
      if (liveIdx === -1) {
        ohlcChart.data.datasets.push({
          label: liveLabel,
          data: livePoints,
          type: 'line',
          borderColor: '#ff4d4d',
          backgroundColor: 'rgba(255,77,77,0.06)',
          pointRadius: 0,
          borderWidth: 1.2,
          tension: 0.15,
          yAxisID: 'y'
        });
      } else {
        ohlcChart.data.datasets[liveIdx].data = livePoints;
      }

      const cndIdx = ohlcChart.data.datasets.findIndex(d => d.type === 'candlestick');
      if (cndIdx !== -1) {
        const ds = ohlcChart.data.datasets[cndIdx];
        if (ds.data.length > MAX_POINTS) ds.data.splice(0, ds.data.length - MAX_POINTS);
      } else {
        if (ohlcChart.data.datasets[0] && ohlcChart.data.datasets[0].data.length > MAX_POINTS) {
          ohlcChart.data.datasets[0].data.splice(0, ohlcChart.data.datasets[0].data.length - MAX_POINTS);
        }
      }

      // Update x-axis to keep last 60 seconds
      if (livePoints.length > 0) {
        ohlcChart.options.scales.x.min = livePoints[0].x;
        ohlcChart.options.scales.x.max = livePoints[livePoints.length - 1].x;
      }

      scheduleIndicatorRecalc();
      try { ohlcChart.update('none'); } catch (e) { try { ohlcChart.update(); } catch(e) {} }
    }

    let _indicatorTimer = null;
    function scheduleIndicatorRecalc() {
      if (_indicatorTimer) return;
      _indicatorTimer = setTimeout(() => {
        _indicatorTimer = null;
        recalcIndicators();
      }, 400);
    }

    function recalcIndicators() {
      if (!ohlcChart || !currentIndicator || currentIndicator === 'none') return;
      const cndIdx = ohlcChart.data.datasets.findIndex(d => d.type === 'candlestick');
      const d0Idx = ohlcChart.data.datasets.findIndex(d => d.label === currentSymbol && (d.type === 'line' || d.type === 'bar'));
      const closes = (cndIdx !== -1 ? ohlcChart.data.datasets[cndIdx].data : ohlcChart.data.datasets[d0Idx]?.data || []).map(d => d.c || d.y).filter(c => c > 0);
      if (closes.length < 10) return;

      const n = parseInt(currentIndicator.replace('ma', ''));
      const ma = simpleMovingAverage(closes, n);
      const maData = ma.map((v, i) => ({ x: (cndIdx !== -1 ? ohlcChart.data.datasets[cndIdx].data[i] : ohlcChart.data.datasets[d0Idx].data[i]).x, y: v })).filter(d => d.y !== null);
      const maIdx = ohlcChart.data.datasets.findIndex(d => d.label === `MA${n}`);
      if (maData.length > 0) {
        if (maIdx === -1) {
          ohlcChart.data.datasets.push({
            label: `MA${n}`,
            data: maData,
            type: 'line',
            borderColor: '#ff7f0e',
            backgroundColor: 'rgba(255,127,14,0.1)',
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2
          });
        } else {
          ohlcChart.data.datasets[maIdx].data = maData;
        }
      }
      try { ohlcChart.update('none'); } catch (e) {}
    }

    // Fallback data simulation
    function generateFallbackPrice(symbol, lastPrice) {
      const basePrices = {
        'BTC': 51000,
        'ETH': 2900,
        'BNB': 350,
        'ADA': 0.52,
        'SOL': 105,
        'DOT': 7.2,
        'DOGE': 0.12,
        'XRP': 0.58,
        'LTC': 72,
        'LINK': 15.8
      };
      const basePrice = lastPrice || basePrices[symbol.toUpperCase()] || 100;
      const change = (Math.random() - 0.5) * basePrice * 0.005;
      return basePrice + change;
    }

    let fallbackInterval = null;
    function startFallbackData(symbol) {
      if (fallbackInterval) clearInterval(fallbackInterval);
      fallbackInterval = setInterval(() => {
        const lastPrice = liveLineBuffer.length > 0 ? liveLineBuffer[liveLineBuffer.length - 1].y : null;
        handleLiveTick(generateFallbackPrice(symbol, lastPrice), Date.now());
      }, 1000);
      $('advisories').innerHTML += '<div class="text-red-600 text-sm mt-2">Live updates paused. Using simulated data. Please refresh or try a different network.</div>';
    }

    function stopFallbackData() {
      if (fallbackInterval) {
        clearInterval(fallbackInterval);
        fallbackInterval = null;
      }
    }

    function renderWatch() {
      const list = getWatch();
      const watchlistEl = $('watchlist');
      if (list.length === 0) { watchlistEl.textContent = 'No symbols.'; return; }
      watchlistEl.innerHTML = list.map(s => `
        <div class="flex justify-between items-center py-2 border-b border-dashed border-slate-100">
          <div><strong>${s}</strong></div>
          <button data-sym="${s}" class="viewBtn px-2 py-1 text-xs rounded bg-sky-600 text-white">View</button>
        </div>
      `).join('');
      document.querySelectorAll('.viewBtn').forEach(btn => { btn.addEventListener('click', () => loadSymbol(btn.dataset.sym)); });
    }

    async function fetchCryptoMarketsFast() {
      const cacheKey = 'crypto_markets_fast';
      const cached = dataCache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < 30000) return cached.data;
      try {
        const cryptoData = await tryCryptoApis();
        dataCache.set(cacheKey, { data: cryptoData, timestamp: Date.now() });
        return cryptoData;
      } catch (error) {
        console.error('All crypto APIs failed:', error);
        return generateLiveCryptoData();
      }
    }

    async function tryCryptoApis() {
      try {
        const response = await fetch('https://api.binance.com/api/v3/ticker/24hr');
        if (response.ok) {
          const data = await response.json();
          const topCryptos = ['BTC','ETH','BNB','ADA','SOL','DOT','DOGE','XRP','LTC','LINK'];
          const filtered = data.filter(item => topCryptos.includes(item.symbol.replace('USDT','')));
          return filtered.map(item => ({
            symbol: item.symbol.replace('USDT',''),
            current_price: parseFloat(item.lastPrice),
            price_change_percentage_24h: parseFloat(item.priceChangePercent),
            price_change_24h: parseFloat(item.priceChange)
          })).slice(0, 10);
        }
      } catch (error) { console.log('Binance API failed, trying CoinGecko...'); }
      try {
        const response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=10&page=1&sparkline=false&price_change_percentage=24h');
        if (response.ok) { return await response.json(); }
      } catch (error) { console.log('CoinGecko failed, trying CoinCap...'); }
      try {
        const response = await fetch('https://api.coincap.io/v2/assets?limit=10');
        if (response.ok) {
          const data = await response.json();
          return data.data.map(item => ({
            symbol: item.symbol,
            current_price: parseFloat(item.priceUsd),
            price_change_percentage_24h: parseFloat(item.changePercent24Hr),
            price_change_24h: parseFloat(item.changePercent24Hr) * parseFloat(item.priceUsd) / 100
          }));
        }
      } catch (error) { console.log('CoinCap failed, using fallback data'); }
      throw new Error('All crypto APIs failed');
    }

    function generateLiveCryptoData() {
      const basePrices = {
        'BTC': 51000 + (Math.random() - 0.5) * 2000,
        'ETH': 2900 + (Math.random() - 0.5) * 200,
        'BNB': 350 + (Math.random() - 0.5) * 20,
        'ADA': 0.52 + (Math.random() - 0.5) * 0.1,
        'SOL': 105 + (Math.random() - 0.5) * 10,
        'DOT': 7.2 + (Math.random() - 0.5) * 0.5,
        'DOGE': 0.12 + (Math.random() - 0.5) * 0.02,
        'XRP': 0.58 + (Math.random() - 0.5) * 0.05,
        'LTC': 72 + (Math.random() - 0.5) * 5,
        'LINK': 15.8 + (Math.random() - 0.5) * 1.5
      };
      return Object.entries(basePrices).map(([symbol, basePrice]) => {
        const changePercent = (Math.random() - 0.5) * 15;
        const currentPrice = basePrice * (1 + changePercent / 100);
        const priceChange = currentPrice - basePrice;
        return { symbol: symbol.toLowerCase(), current_price: currentPrice, price_change_percentage_24h: changePercent, price_change_24h: priceChange };
      });
    }

    async function loadCryptoAdvice() {
      const now = Date.now();
      if (now - lastCryptoUpdate < 10000 && $('cryptoAdvice').children.length > 1) return;
      lastCryptoUpdate = now;
      $('cryptoAdvice').innerHTML = '<div class="loading pulse text-sm">Loading live crypto data...</div>';
      try {
        const cryptoData = await fetchCryptoMarketsFast();
        renderCryptoAdvice(cryptoData);
      } catch (error) {
        console.error('Error loading crypto advice:', error);
        renderCryptoAdvice(generateLiveCryptoData());
      }
    }

    function renderCryptoAdvice(cryptoData) {
      const cryptoAdviceEl = $('cryptoAdvice');
      const nodes = cryptoData.map(crypto => {
        const symbol = (crypto.symbol || 'CRYPTO').toUpperCase();
        const price = crypto.current_price?.toLocaleString('en-US', { style:'currency', currency:'USD', minimumFractionDigits: crypto.current_price < 1 ? 4 : 2, maximumFractionDigits: crypto.current_price < 1 ? 4 : 2 }) || '$0.00';
        const change = crypto.price_change_percentage_24h || 0;
        const changeFormatted = Math.abs(change).toFixed(2);
        const changeColor = change >= 0 ? '#00cc00' : '#d32f2f';
        const changeSymbol = change >= 0 ? '+' : '';
        let recommendation = 'Hold', recommendationColor = '#6b7b8c';
        if (change > 8) { recommendation = 'Consider Taking Profits'; recommendationColor = '#d32f2f'; }
        else if (change > 3) { recommendation = 'Bullish - Monitor'; recommendationColor = '#00cc00'; }
        else if (change < -8) { recommendation = 'Potential Buying Opportunity'; recommendationColor = '#00cc00'; }
        else if (change < -3) { recommendation = 'Bearish - Caution'; recommendationColor = '#d32f2f'; }
        return `
          <div class="py-2 border-b border-slate-100">
            <div class="flex justify-between items-center">
              <strong>${symbol}</strong>
              <span class="font-semibold">${price}</span>
            </div>
            <div class="meta" style="color:${changeColor};font-weight:500">${changeSymbol}${changeFormatted}% (24h)</div>
            <div class="mt-1 text-xs" style="color:${recommendationColor}"><em>${recommendation}</em></div>
          </div>
        `;
      });
      cryptoAdviceEl.innerHTML = `
        <div class="text-xs text-sky-600 text-right mb-2">Updated: ${new Date().toLocaleTimeString()}</div>
        ${nodes.join('')}
        <div class="mt-3 text-center">
          <button onclick="loadCryptoAdvice()" class="px-3 py-1 text-xs rounded bg-sky-600 text-white">Refresh Crypto</button>
        </div>
      `;
    }

    async function fetchWithTimeout(url, timeout = 8000) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      try { const response = await fetch(url, { signal: controller.signal }); clearTimeout(timeoutId); return response; }
      catch (error) { clearTimeout(timeoutId); throw error; }
    }

    async function fetchStockData(symbol, range = '1D') {
      const cacheKey = `stock_${symbol}_${range}`;
      const cached = dataCache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < CACHE_DURATION) return cached.data;
      try {
        const ranges = { '1D':'1d','1W':'5d','1M':'1mo','3M':'3mo','1Y':'1y' };
        const yahooRange = ranges[range] || '1d';
        const interval = range === '1D' ? '5m' : '1d';
        const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?range=${yahooRange}&interval=${interval}`;
        const proxyUrl = 'https://api.allorigins.win/raw?url=';
        const response = await fetchWithTimeout(proxyUrl + encodeURIComponent(yahooUrl), 5000);
        const data = await response.json();
        if (!data.chart?.result?.[0]) throw new Error('No chart data from Yahoo');
        const result = data.chart.result[0];
        const quotes = result.indicators.quote[0];
        const timestamps = result.timestamp;
        if (!timestamps || timestamps.length === 0) throw new Error('No timestamp data');
        const ohlc = timestamps.map((t, i) => ({ t: t * 1000, o: quotes.open[i] || quotes.close[i] || 0, h: quotes.high[i] || quotes.close[i] || 0, l: quotes.low[i] || quotes.close[i] || 0, c: quotes.close[i] || 0 })).filter(d => d.c > 0 && d.o > 0);
        const resultData = { ohlc, last: timestamps.length ? new Date(timestamps[timestamps.length - 1] * 1000).toISOString() : null };
        dataCache.set(cacheKey, { data: resultData, timestamp: Date.now() });
        return resultData;
      } catch (error) {
        console.error(`Yahoo Finance error for ${symbol}:`, error);
        try {
          const interval = range === '1D' ? '5min' : 'daily';
          const functionName = range === '1D' ? 'TIME_SERIES_INTRADAY' : 'TIME_SERIES_DAILY';
          const url = `https://www.alphavantage.co/query?function=${functionName}&symbol=${symbol}&interval=${interval}&apikey=${ALPHA_VANTAGE_API_KEY}&outputsize=compact`;
          const response = await fetchWithTimeout(url, 5000);
          const data = await response.json();
          let timeSeries;
          if (range === '1D') timeSeries = data['Time Series (5min)']; else timeSeries = data['Time Series (Daily)'];
          if (!timeSeries) throw new Error('No time series data available');
          const ohlc = [];
          const dates = Object.keys(timeSeries).sort();
          for (const date of dates) {
            const entry = timeSeries[date];
            ohlc.push({ t: new Date(date).getTime(), o: parseFloat(entry['1. open']), h: parseFloat(entry['2. high']), l: parseFloat(entry['3. low']), c: parseFloat(entry['4. close']) });
          }
          const resultData = { ohlc: ohlc.reverse(), last: dates[dates.length - 1] };
          dataCache.set(cacheKey, { data: resultData, timestamp: Date.now() });
          return resultData;
        } catch (avError) {
          console.error(`Alpha Vantage error for ${symbol}:`, avError);
          throw new Error(`Unable to fetch data for ${symbol}. Please try another symbol.`);
        }
      }
    }

    async function fetchCryptoData(symbol) {
      const cacheKey = `crypto_${symbol}`;
      const cached = dataCache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < CACHE_DURATION) return cached.data;
      try {
        const coinMap = { 'BTC':'bitcoin','ETH':'ethereum','ADA':'cardano','SOL':'solana','DOT':'polkadot','DOGE':'dogecoin','XRP':'ripple','LTC':'litecoin','BNB':'binancecoin','LINK':'chainlink' };
        const coinId = coinMap[symbol] || symbol.toLowerCase();
        const response = await fetchWithTimeout(`https://api.coingecko.com/api/v3/coins/${coinId}/ohlc?vs_currency=usd&days=1`, 5000);
        const data = await response.json();
        if (!data || data.length === 0) throw new Error('No crypto data available');
        const ohlc = data.map(item => ({ t: item[0], o: item[1], h: item[2], l: item[3], c: item[4] }));
        const resultData = { ohlc, last: new Date().toISOString() };
        dataCache.set(cacheKey, { data: resultData, timestamp: Date.now() });
        return resultData;
      } catch (error) {
        console.error(`Crypto data error for ${symbol}:`, error);
        throw new Error(`Unable to fetch crypto data for ${symbol}`);
      }
    }

    function simpleMovingAverage(arr, n) {
      const res = [];
      for (let i = 0; i < arr.length; i++) {
        if (i < n - 1) res.push(null);
        else { let sum = 0; for (let j = 0; j < n; j++) sum += arr[i - j] || 0; res.push(sum / n); }
      }
      return res;
    }

    function renderChart(ohlc, label) {
      const canvas = $('ohlcChart');
      const ctx = canvas.getContext('2d');
      if (ohlcChart) {
        try { ohlcChart.destroy(); } catch(e) {}
      }
      if (!ohlc || ohlc.length === 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = '16px Arial';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'center';
        ctx.fillText('No data available', canvas.width / 2, canvas.height / 2);
        return;
      }

      const ohlcData = ohlc.map(d => ({ x: d.t, o: d.o, h: d.h, l: d.l, c: d.c }));
      const datasets = [];
      if (currentChartType === 'candlestick') {
        datasets.push({
          label: label,
          data: ohlcData,
          type: 'candlestick',
          color: { up: '#00cc00', down: '#ff3333', unchanged: '#999999' }
        });
      } else {
        datasets.push({
          label: label + ' Price',
          data: ohlcData.map(d => ({ x: d.x, y: d.c })),
          type: currentChartType,
          borderColor: '#0b76d1',
          backgroundColor: currentChartType === 'bar' ? 'rgba(11,118,209,0.6)' : 'rgba(11,118,209,0.1)',
          fill: currentChartType !== 'bar',
          tension: 0.4,
          pointRadius: 0,
          borderWidth: 2
        });
      }

      const config = {
        type: currentChartType === 'candlestick' ? 'candlestick' : 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          plugins: {
            legend: { display: true, position: 'top', labels: { font: { size: 12, family: 'Inter' } } },
            tooltip: { 
              mode: 'index', 
              intersect: false, 
              backgroundColor: 'rgba(0,0,0,0.8)', 
              titleFont: { size: 12, family: 'Inter' }, 
              bodyFont: { size: 12, family: 'Inter' }, 
              padding: 10 
            },
            zoom: {
              pan: { enabled: true, mode: 'x' },
              zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' }
            }
          },
          scales: {
            x: { 
              type: 'time', 
              time: { unit: currentRange === '1D' ? 'second' : 'day', displayFormats: { second: 'HH:mm:ss', day: 'MMM dd' } }, 
              grid: { color: 'rgba(0,0,0,0.04)' }, 
              ticks: { maxTicksLimit: 8, font: { size: 10, family: 'Inter' } },
              min: ohlcData.length > MAX_POINTS ? ohlcData[ohlcData.length - MAX_POINTS].x : ohlcData[0].x,
              max: ohlcData[ohlcData.length - 1].x
            },
            y: { 
              beginAtZero: false, 
              grid: { color: 'rgba(0,0,0,0.04)' }, 
              ticks: { 
                callback: function(value) { return '$' + value.toFixed(2); }, 
                font: { size: 10, family: 'Inter' } 
              } 
            }
          }
        }
      };

      try { ohlcChart = new Chart(ctx, config); } catch (e) { console.error('Chart render error:', e); }
      applyZoomFromSlider();
      if (currentIndicator !== 'none') scheduleIndicatorRecalc();
    }

    function computeSignalsFromOHLC(ohlc) {
      if (!ohlc || ohlc.length < 20) return { recommendation: 'Hold', reason: 'Insufficient data for analysis' };
      const closes = ohlc.map(d => d.c).filter(c => c > 0);
      const ma10 = simpleMovingAverage(closes, 10);
      const ma50 = simpleMovingAverage(closes, 50);
      const currentMA10 = ma10[ma10.length - 1];
      const currentMA50 = ma50[ma50.length - 1];
      const currentPrice = closes[closes.length - 1];
      const signal = { recommendation: 'Hold', reason: 'No clear trend detected' };
      if (currentMA10 > currentMA50 && currentPrice > currentMA10) { signal.recommendation = 'Buy'; signal.reason = 'Bullish trend: Price above MA10 and MA10 above MA50'; }
      else if (currentMA10 < currentMA50 && currentPrice < currentMA10) { signal.recommendation = 'Sell'; signal.reason = 'Bearish trend: Price below MA10 and MA10 below MA50'; }
      const shortTermMomentum = ((currentPrice - closes[closes.length - 5]) / closes[closes.length - 5]) * 100;
      if (Math.abs(shortTermMomentum) > 3) signal.momentum = `${shortTermMomentum.toFixed(2)}% over last 5 periods`;
      return signal;
    }

    function updateAdvisories(symbol, data) {
      const advisoriesEl = $('advisories');
      if (data.error) { advisoriesEl.innerHTML = `<div class="text-red-600"><strong>${symbol}</strong>: ${data.error}</div>`; return; }
      const signal = computeSignalsFromOHLC(data.ohlc);
      advisoriesEl.innerHTML = `
        <strong>${symbol}</strong>
        <div class="mt-2">Recommendation: <strong>${signal.recommendation}</strong></div>
        <div class="meta mt-2">${signal.reason}</div>
        ${signal.momentum ? `<div class="meta mt-2">Momentum: ${signal.momentum}</div>` : ''}
        <div class="mt-3 text-sm text-sky-600"><strong>Live Data Analysis</strong> - Based on ${useFallbackData ? 'simulated' : 'real market'} data</div>
      `;
    }

    async function loadNews() {
      const now = Date.now();
      if (now - lastNewsUpdate < NEWS_UPDATE_INTERVAL && $('newsGrid').children.length > 1) return;
      $('newsGrid').innerHTML = '<div class="loading pulse text-sm">Loading latest news...</div>';
      lastNewsUpdate = now;
      try {
        const fallbackNews = [
          { title: 'Global Markets Show Resilience Amid Economic Shifts', summary: 'Major indices demonstrate strength as investors adapt to new market conditions.', image: 'https://images.unsplash.com/photo-1611974789855-9c2a0a7236a3?w=600&h=400&fit=crop', url: '#', date: new Date().toISOString() },
          { title: 'Tech Sector Leads Market Recovery in Q4', summary: 'Technology stocks show strong performance driven by AI and cloud computing growth.', image: 'https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=600&h=400&fit=crop', url: '#', date: new Date(Date.now()-86400000).toISOString() },
          { title: 'Cryptocurrency Market Experiences Volatility', summary: 'Digital assets fluctuate as regulatory developments impact investor sentiment.', image: 'https://images.unsplash.com/photo-1621761191319-c6fb62004040?w=600&h=400&fit=crop', url: '#', date: new Date(Date.now()-172800000).toISOString() },
          { title: 'Federal Reserve Maintains Interest Rate Policy', summary: 'Central bank holds steady on rates amid stable inflation indicators.', image: 'https://images.unsplash.com/photo-1560520653-9e0e4c89eb11?w=600&h=400&fit=crop', url: '#', date: new Date(Date.now()-259200000).toISOString() },
          { title: 'Energy Sector Benefits from Supply Adjustments', summary: 'Oil and gas companies see gains as production levels stabilize.', image: 'https://images.unsplash.com/photo-1504893524553-b855bceeacef?w=600&h=400&fit=crop', url: '#', date: new Date(Date.now()-345600000).toISOString() },
          { title: 'Emerging Markets Offer Growth Opportunities', summary: 'Developing economies present attractive investment prospects for 2024.', image: 'https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=600&h=400&fit=crop', url: '#', date: new Date(Date.now()-432000000).toISOString() }
        ];
        const newsItems = fallbackNews.slice(0, 6);
        const newsGrid = $('newsGrid');
        newsGrid.innerHTML = newsItems.map(item => {
          const title = item.title.length > 70 ? item.title.substring(0,70) + '...' : item.title;
          const summary = item.summary.length > 100 ? item.summary.substring(0,100) + '...' : item.summary;
          return `
            <a class="newsCard block bg-white rounded-lg overflow-hidden border card-border hover:shadow-md transition-transform" href="${item.url}" target="_blank" rel="noopener noreferrer">
              <img src="${item.image}" alt="${title}" loading="lazy" class="w-full h-36 object-cover">
              <div class="p-3">
                <h5 class="text-sm font-semibold mb-1">${title}</h5>
                <div class="meta text-xs">${summary}</div>
                <div class="meta text-xs mt-2">${new Date(item.date).toLocaleDateString()}</div>
              </div>
            </a>
          `;
        }).join('');
      } catch (error) {
        console.error('Error loading news:', error);
        $('newsGrid').innerHTML = '<div class="error text-sm">News feed updating...</div>';
      }
    }

    async function loadPosts() {
      const watchlist = getWatch().slice(0,9);
      const postsArea = $('postsArea');
      postsArea.innerHTML = '<div class="loading pulse">Updating market data...</div>';
      try {
        const posts = await Promise.allSettled(watchlist.map(async (symbol) => {
          try {
            const basePrices = { 'AAPL':180+(Math.random()-0.5)*10, 'MSFT':330+(Math.random()-0.5)*15, 'GOOGL':140+(Math.random()-0.5)*8, 'TSLA':200+(Math.random()-0.5)*20, 'BTC':50000+(Math.random()-0.5)*2000, 'ETH':3000+(Math.random()-0.5)*200, 'AMZN':170+(Math.random()-0.5)*10, 'NVDA':450+(Math.random()-0.5)*25, 'META':320+(Math.random()-0.5)*15 };
            const basePrice = basePrices[symbol] || 100 + (Math.random()-0.5)*50;
            const change = (Math.random()-0.5) * basePrice * 0.1;
            const currentPrice = basePrice + change;
            const changePercent = (change/basePrice)*100;
            const changeClass = change >= 0 ? 'text-emerald-600' : 'text-red-600';
            const changeSymbol = change >= 0 ? '+' : '';
            return `<div class="post bg-white rounded-lg p-3 border card-border"><h4 class="text-sm font-semibold">${symbol}</h4><div class="meta">$${currentPrice.toFixed(2)}</div><div class="${changeClass} mt-1 text-sm">${changeSymbol}${change.toFixed(2)} (${changeSymbol}${Math.abs(changePercent).toFixed(2)}%)</div><div class="text-xs text-sky-600 mt-2">Live</div></div>`;
          } catch (error) {
            return `<div class="post bg-white rounded-lg p-3 border card-border"><h4 class="text-sm font-semibold">${symbol}</h4><div class="meta">Data updating</div><div class="change">--</div></div>`;
          }
        }));
        const successfulPosts = posts.filter(p => p.status === 'fulfilled').map(p => p.value);
        postsArea.innerHTML = successfulPosts.join('');
      } catch (error) {
        console.error('Error loading posts:', error);
        postsArea.innerHTML = '<div class="error text-sm">Market data updating...</div>';
      }
    }

    async function loadSymbol(symbol, range = '1D') {
      if (!symbol || symbol.trim() === '') return;
      currentSymbol = symbol.toUpperCase().trim();
      currentRange = range;
      const chartTitle = $('chartTitle');
      const chartUpdated = $('chartUpdated');
      chartTitle.textContent = `Loading ${currentSymbol} (${range})...`;
      chartTitle.classList.add('loading');

      try {
        let data;
        if (['BTC','ETH','ADA','SOL','DOT','DOGE','XRP','LTC','BNB','LINK'].includes(currentSymbol)) {
          data = await fetchCryptoData(currentSymbol);
          currentBucket = null;
          liveLineBuffer = [];
          connectBinance(currentSymbol + 'USDT');
        } else {
          data = await fetchStockData(currentSymbol, range);
          if (binanceWS) try { binanceWS.close(); } catch(e) {}
          updateWebSocketStatus('disconnected', 'Not available for stocks');
          stopFallbackData();
          currentBucket = null;
          liveLineBuffer = [];
        }

        renderChart(data.ohlc, currentSymbol);
        chartUpdated.textContent = data.last ? new Date(data.last).toLocaleString() : 'Just now';
        updateAdvisories(currentSymbol, data);
        chartTitle.classList.remove('loading');
        chartTitle.textContent = `${currentSymbol} (${range}) - Last: $${(liveLineBuffer[liveLineBuffer.length - 1]?.y || data.ohlc[data.ohlc.length - 1]?.c || 0).toFixed(2)}`;
      } catch (error) {
        console.error(`Error loading symbol ${currentSymbol}:`, error);
        chartTitle.classList.remove('loading');
        chartTitle.textContent = `${currentSymbol} (${range})`;
        chartUpdated.textContent = 'Data updating';
        $('advisories').innerHTML = `<div class="text-red-600"><strong>${currentSymbol}</strong>: ${error.message}</div><div class="mt-2 text-sm">Please try a different symbol or refresh the page.</div>`;
      }
    }

    function applyZoomFromSlider() {
      const slider = $('zoomSlider');
      if (!ohlcChart || !slider) return;
      const value = parseInt(slider.value, 10);
      const ds = ohlcChart.data.datasets && ohlcChart.data.datasets[0];
      if (!ds || !ds.data || ds.data.length === 0) return;
      const total = ds.data.length;
      const visible = Math.max(10, Math.round(total * (value / 100)));
      const lastIndex = total - 1;
      const firstIndex = Math.max(0, lastIndex - visible + 1);
      const minT = ds.data[firstIndex].x;
      const maxT = ds.data[lastIndex].x;
      try {
        ohlcChart.options.scales.x.min = minT;
        ohlcChart.options.scales.x.max = maxT;
        ohlcChart.update('none');
      } catch (e) {
        console.error('applyZoom error', e);
      }
    }

    document.addEventListener('input', (e) => {
      if (e.target && e.target.id === 'zoomSlider') applyZoomFromSlider();
    });

    async function loadAll() {
      renderWatch();
      await Promise.allSettled([loadCryptoAdvice(), loadNews(), loadPosts()]);
      const ranges = ['1D','1W','1M','3M','1Y'];
      const timeRangeDiv = $('timeRange');
      timeRangeDiv.innerHTML = ranges.map(range => `<button class="px-2 py-1 rounded text-xs ${range === '1D' ? 'bg-sky-600 text-white' : 'bg-slate-100'}" data-range="${range}">${range}</button>`).join('');
      timeRangeDiv.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', () => {
          timeRangeDiv.querySelector('.bg-sky-600')?.classList.remove('bg-sky-600','text-white');
          btn.classList.add('bg-sky-600','text-white');
          if (currentSymbol) loadSymbol(currentSymbol, btn.dataset.range);
        });
      });

      const chartTypes = [{ type: 'candlestick', label: 'Candlestick' }, { type: 'line', label: 'Line' }, { type: 'bar', label: 'Bar' }];
      const chartTypeDiv = $('chartType');
      chartTypeDiv.innerHTML = chartTypes.map(({type,label}) => `<button class="px-2 py-1 rounded text-xs ${type === 'candlestick' ? 'bg-slate-200' : 'bg-slate-100'}" data-type="${type}">${label}</button>`).join('');
      chartTypeDiv.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', () => {
          chartTypeDiv.querySelector('.bg-sky-600')?.classList.remove('bg-sky-600','text-white');
          chartTypeDiv.querySelector('.bg-slate-200')?.classList.remove('bg-slate-200');
          btn.classList.add('bg-slate-200');
          currentChartType = btn.dataset.type;
          if (currentSymbol) loadSymbol(currentSymbol, currentRange);
        });
      });

      $('indicatorSelect').addEventListener('change', (e) => {
        currentIndicator = e.target.value;
        if (currentSymbol) loadSymbol(currentSymbol, currentRange);
      });

      $('zoomSlider').value = 100;

      const firstSymbol = getWatch()[0];
      if (firstSymbol) loadSymbol(firstSymbol);
    }

    $('loadBtn').addEventListener('click', () => {
      const symbol = $('globalSearch').value.trim();
      if (!symbol) { alert('Please enter a symbol'); return; }
      const watchlist = getWatch();
      if (!watchlist.includes(symbol.toUpperCase())) { watchlist.unshift(symbol.toUpperCase()); saveWatch(watchlist); renderWatch(); }
      $('globalSearch').value = '';
      loadSymbol(symbol);
    });

    $('globalSearch').addEventListener('keypress', (e) => { if (e.key === 'Enter') $('loadBtn').click(); });

    $('sendBtn').addEventListener('click', () => {
      const name = $('name').value.trim(); const email = $('email').value.trim(); const message = $('message').value.trim();
      if (!name || !email || !message) { $('sendStatus').textContent = 'Please fill all fields.'; return; }
      const subject = `Contact from ${name} - JDGlobal Markets`;
      const body = `Message: ${message}\n\nFrom: ${name} <${email}>`;
      window.location.href = `mailto:wambuamwanza6@gmail.com?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
      $('sendStatus').textContent = 'Opening email client...';
    });

    document.addEventListener('DOMContentLoaded', () => {
      loadAll();
      setInterval(() => {
        loadCryptoAdvice(); loadPosts();
        if (Date.now() - lastNewsUpdate >= NEWS_UPDATE_INTERVAL) loadNews();
        if (currentSymbol && !useFallbackData && ['BTC','ETH','ADA','SOL','DOT','DOGE','XRP','LTC','BNB','LINK'].includes(currentSymbol)) {
          connectBinance(currentSymbol + 'USDT');
        }
      }, 60000);
    });
  </script>
</body>
</html>
