<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JDGlobal Markets</title>
  <meta name="description" content="Advanced finance dashboard with candlestick charts, indicators, trade advisories, crypto/forex signals and news thumbnails." />

  <!-- Chart.js + Financial plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.0/dist/chartjs-chart-financial.min.js"></script>

  <style>
    html, body { all: unset; display: block; height: 100%; }
    * { box-sizing: border-box; }
    body { font-family: Inter, Segoe UI, Roboto, Arial, sans-serif; background: #f6f8fb; margin: 0; padding: 18px; color: #0b2240; }
    #app { max-width: 1200px; margin: 0 auto; background: #fff; border-radius: 12px; padding: 18px; border: 1px solid #e6eef6; box-shadow: 0 12px 40px rgba(13, 30, 50, 0.06); }
    .header { display: flex; align-items: center; justify-content: space-between; padding-bottom: 12px; border-bottom: 1px solid #e6eef6; }
    .brand { display: flex; gap: 12px; align-items: center; }
    .logo { width: 56px; height: 56px; border-radius: 10px; background: linear-gradient(135deg, #e6f2ff, #fff); display: flex; align-items: center; justify-content: center; font-weight: 800; color: #0b76d1; }
    .title { font-size: 18px; font-weight: 700; }
    .subtitle { font-size: 13px; color: #6b7b8c; }
    .controls { display: flex; gap: 8px; align-items: center; }
    .controls input, .controls select { padding: 8px; border-radius: 8px; border: 1px solid #dcebf7; font-size: 14px; }
    .controls button { padding: 8px 12px; border-radius: 8px; border: none; background: #0b76d1; color: #fff; cursor: pointer; font-size: 14px; }
    .grid { display: grid; grid-template-columns: 320px 1fr; gap: 18px; margin-top: 16px; }
    .left { display: flex; flex-direction: column; gap: 12px; }
    .card { background: #fff; border: 1px solid #eef6fb; border-radius: 10px; padding: 12px; }
    .chartCard { display: flex; flex-direction: column; }
    .chartWrap { height: 420px; position: relative; }
    .chartToolbar { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; flex-wrap: wrap; }
    .timeRange { display: flex; gap: 4px; }
    .timeRange button { padding: 4px 8px; font-size: 12px; background: #f1f6fb; border: 1px solid #dcebf7; border-radius: 4px; cursor: pointer; }
    .timeRange button.active { background: #0b76d1; color: #fff; }
    .chartType { display: flex; gap: 4px; }
    .chartType button { padding: 4px 8px; font-size: 12px; background: #f1f6fb; border: 1px solid #dcebf7; border-radius: 4px; cursor: pointer; }
    .chartType button.active { background: #0b76d1; color: #fff; }
    .indicatorSelect { padding: 4px 8px; font-size: 12px; border-radius: 4px; border: 1px solid #dcebf7; }
    .newsGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 12px; }
    .newsCard { background: #fff; border: 1px solid #eef6fb; border-radius: 8px; overflow: hidden; text-decoration: none; color: inherit; display: block; transition: transform 0.2s; }
    .newsCard:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); }
    .newsCard img { width: 100%; height: 140px; object-fit: cover; }
    .newsCard .body { padding: 10px; }
    .newsCard h5 { margin: 0 0 6px 0; font-size: 15px; }
    .newsCard .meta { font-size: 12px; color: #6b7b8c; }
    .postsGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 12px; }
    .post { padding: 12px; border-radius: 8px; background: linear-gradient(180deg, #fff, #fbfdff); border: 1px solid #eef6fb; display: flex; flex-direction: column; justify-content: space-between; }
    .post h4 { margin: 0 0 6px 0; font-size: 16px; }
    .post .meta { font-size: 14px; color: #0b2240; }
    .post .change { font-size: 14px; color: #d32f2f; }
    .post .change.green { color: #00cc00; }
    footer { margin-top: 18px; padding-top: 12px; border-top: 1px solid #eef6fb; display: flex; justify-content: space-between; align-items: flex-start; gap: 18px; }
    .contact input, .contact textarea { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #dcebf7; margin-top: 8px; }
    .contact button { margin-top: 8px; padding: 10px 12px; border-radius: 8px; border: none; background: #0b76d1; color: #fff; cursor: pointer; }
    .advice { background: linear-gradient(180deg, #fff, #fbfdff); padding: 10px; border-radius: 8px; border: 1px solid #eef6fb; }
    .error { color: #d32f2f; font-style: italic; }
    .loading { opacity: 0.6; }
    .success { color: #00cc00; }
    .pulse { animation: pulse 1.5s infinite; }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    @media (max-width: 1100px) { .newsGrid, .postsGrid { grid-template-columns: repeat(2, 1fr); } .grid { grid-template-columns: 1fr; } }
    @media (max-width: 700px) { .newsGrid, .postsGrid { grid-template-columns: 1fr; } .chartToolbar { flex-direction: column; align-items: flex-start; } }
  </style>
</head>
<body>
  <div id="app">
    <div class="header">
      <div class="brand">
        <div class="logo">JDG</div>
        <div>
          <div class="title">JDGlobal Markets</div>
          <div class="subtitle">Real-time candlesticks, indicators, trade advisories & market news</div>
        </div>
      </div>
      <div class="controls">
        <input id="globalSearch" placeholder="Symbol e.g. AAPL, TSLA, BTC, EURUSD">
        <button id="loadBtn">Load</button>
      </div>
    </div>

    <main class="grid">
      <aside class="left">
        <div class="card">
          <h4>Watchlist</h4>
          <div id="watchlist">Loading…</div>
          <div style="margin-top:8px"><small class="meta">Tip: Add any global ticker (US/EU/Asia). For forex use EURUSD, for crypto use BTC, ETH etc.</small></div>
        </div>
        <div class="card">
          <h4>Trade Advisories</h4>
          <div id="advisories" class="advice">Loading advisories…</div>
        </div>
        <div class="card">
          <h4>Crypto Suggestions</h4>
          <div id="cryptoAdvice" class="advice">Loading crypto suggestions…</div>
        </div>
      </aside>
      <section>
        <div class="card chartCard">
          <div class="chartToolbar">
            <div><strong id="chartTitle">Select a symbol</strong></div>
            <div style="margin-left:auto" class="meta">Updated: <span id="chartUpdated">—</span></div>
            <div class="timeRange" id="timeRange"></div>
            <div class="chartType" id="chartType"></div>
            <select id="indicatorSelect" class="indicatorSelect">
              <option value="none">MA: None</option>
              <option value="ma10">MA10</option>
              <option value="ma20">MA20</option>
              <option value="ma50">MA50</option>
            </select>
          </div>
          <div class="chartWrap"><canvas id="ohlcChart"></canvas></div>
          <div style="margin-top:12px">
            <strong>Market News</strong>
            <div class="newsGrid" id="newsGrid">Loading news…</div>
          </div>
        </div>
        <div class="card" style="margin-top:12px">
          <h4 style="margin-top:0">Market Watch Posts</h4>
          <div class="postsGrid" id="postsArea">Loading posts…</div>
        </div>
      </section>
    </main>

    <footer>
      <div>
        <div style="font-weight:700">Market Pulse</div>
        <div class="meta">Real Markets Data and Analysis Dashboard by JDG Team</div>
      </div>
      <div class="contact card" style="width:360px">
        <strong>Contact</strong>
        <div class="meta">Messages will be prepared for: <strong>wambuamwanza6@gmail.com</strong></div>
        <input id="name" placeholder="Your name" />
        <input id="email" placeholder="Your email" />
        <textarea id="message" rows="4" placeholder="Your message"></textarea>
        <button id="sendBtn">Send</button>
        <div id="sendStatus" class="meta" style="margin-top:8px"></div>
      </div>
    </footer>
  </div>
<script>
// CONFIG
const ALPHA_VANTAGE_API_KEY = 'INZ7GV3B33PXV2QM';
let lastNewsUpdate = 0;
let lastCryptoUpdate = 0;
const NEWS_UPDATE_INTERVAL = 300000;
const CRYPTO_UPDATE_INTERVAL = 60000;
let currentSymbol = '';
let currentRange = '1D';
let currentChartType = 'candlestick';
let currentIndicator = 'none';
let ohlcChart = null;
let ws = null; // WebSocket connection
let wsData = []; // Store WebSocket kline data
const MAX_CANDLES = 100; // Limit to 100 candles for performance

// Helpers
const $ = id => document.getElementById(id);

// Enhanced data cache
const dataCache = new Map();
const CACHE_DURATION = 60000;

// Watchlist storage
function getWatch() {
  try {
    return JSON.parse(localStorage.getItem('mp_watch') || '["AAPL","MSFT","GOOGL","TSLA","BTC"]');
  } catch (e) {
    return ['AAPL', 'MSFT', 'GOOGL', 'TSLA', 'BTC'];
  }
}

function saveWatch(a) {
  localStorage.setItem('mp_watch', JSON.stringify(a));
}

function renderWatch() {
  const list = getWatch();
  const watchlistEl = $('watchlist');
  if (list.length === 0) {
    watchlistEl.textContent = 'No symbols.';
    return;
  }
  watchlistEl.innerHTML = list.map(s => `
    <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px dashed #f1f6fb">
      <div><strong>${s}</strong></div>
      <button data-sym="${s}" class="viewBtn" style="padding:4px 8px;font-size:12px;background:#0b76d1;color:#fff;border:none;border-radius:4px;cursor:pointer">View</button>
    </div>
  `).join('');
  document.querySelectorAll('.viewBtn').forEach(btn => {
    btn.addEventListener('click', () => loadSymbol(btn.dataset.sym));
  });
}

// Binance WebSocket for real-time crypto data
function connectWebSocket(symbol) {
  if (ws) {
    ws.close();
    ws = null;
    wsData = [];
  }

  const cryptoSymbols = ['BTC', 'ETH', 'ADA', 'SOL', 'DOT', 'DOGE', 'XRP', 'LTC', 'BNB', 'LINK'];
  if (!cryptoSymbols.includes(symbol.toUpperCase())) {
    return; // WebSocket only for crypto symbols
  }

  const wsSymbol = symbol.toLowerCase() + 'usdt@klines_1s'; // 1-second kline stream
  ws = new WebSocket(`wss://stream.binance.com:9443/ws/${wsSymbol}`);

  ws.onopen = () => {
    console.log(`WebSocket connected for ${symbol}`);
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if (data.e === 'kline') {
      const kline = data.k;
      const newCandle = {
        t: kline.t,
        o: parseFloat(kline.o),
        h: parseFloat(kline.h),
        l: parseFloat(kline.l),
        c: parseFloat(kline.c)
      };

      // Add new candle or update the last one if not closed
      if (wsData.length && wsData[wsData.length - 1].t === newCandle.t) {
        wsData[wsData.length - 1] = newCandle;
      } else {
        wsData.push(newCandle);
      }

      // Keep only the last MAX_CANDLES
      if (wsData.length > MAX_CANDLES) {
        wsData = wsData.slice(-MAX_CANDLES);
      }

      // Update chart with WebSocket data
      renderChart(wsData, symbol);
      $('chartUpdated').textContent = new Date().toLocaleString();
      updateAdvisories(symbol, { ohlc: wsData });
    }
  };

  ws.onerror = (error) => {
    console.error('WebSocket error:', error);
  };

  ws.onclose = () => {
    console.log('WebSocket closed');
    // Attempt to reconnect after 5 seconds
    setTimeout(() => {
      if (currentSymbol === symbol) {
        connectWebSocket(symbol);
      }
    }, 5000);
  };
}

// Crypto data fetch (fallback for initial load)
async function fetchCryptoMarketsFast() {
  const cacheKey = 'crypto_markets_fast';
  const cached = dataCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < 30000) {
    return cached.data;
  }
  try {
    const response = await fetch('https://api.binance.com/api/v3/ticker/24hr');
    if (response.ok) {
      const data = await response.json();
      const topCryptos = ['BTC', 'ETH', 'BNB', 'ADA', 'SOL', 'DOT', 'DOGE', 'XRP', 'LTC', 'LINK'];
      const filtered = data.filter(item => topCryptos.includes(item.symbol.replace('USDT', '')));
      const result = filtered.map(item => ({
        symbol: item.symbol.replace('USDT', ''),
        current_price: parseFloat(item.lastPrice),
        price_change_percentage_24h: parseFloat(item.priceChangePercent),
        price_change_24h: parseFloat(item.priceChange)
      })).slice(0, 10);
      dataCache.set(cacheKey, { data: result, timestamp: Date.now() });
      return result;
    }
  } catch (error) {
    console.log('Binance API failed, using fallback data');
    return generateLiveCryptoData();
  }
}

function generateLiveCryptoData() {
  const basePrices = {
    'BTC': 51000 + (Math.random() - 0.5) * 2000,
    'ETH': 2900 + (Math.random() - 0.5) * 200,
    'BNB': 350 + (Math.random() - 0.5) * 20,
    'ADA': 0.52 + (Math.random() - 0.5) * 0.1,
    'SOL': 105 + (Math.random() - 0.5) * 10,
    'DOT': 7.2 + (Math.random() - 0.5) * 0.5,
    'DOGE': 0.12 + (Math.random() - 0.5) * 0.02,
    'XRP': 0.58 + (Math.random() - 0.5) * 0.05,
    'LTC': 72 + (Math.random() - 0.5) * 5,
    'LINK': 15.8 + (Math.random() - 0.5) * 1.5
  };
  return Object.entries(basePrices).map(([symbol, basePrice]) => {
    const changePercent = (Math.random() - 0.5) * 15;
    const currentPrice = basePrice * (1 + changePercent / 100);
    const priceChange = currentPrice - basePrice;
    return {
      symbol: symbol.toLowerCase(),
      current_price: currentPrice,
      price_change_percentage_24h: changePercent,
      price_change_24h: priceChange
    };
  });
}

async function loadCryptoAdvice() {
  const now = Date.now();
  if (now - lastCryptoUpdate < 10000 && $('cryptoAdvice').children.length > 1) {
    return;
  }
  lastCryptoUpdate = now;
  $('cryptoAdvice').innerHTML = '<div class="loading pulse">Loading live crypto data...</div>';
  try {
    const cryptoData = await fetchCryptoMarketsFast();
    renderCryptoAdvice(cryptoData);
  } catch (error) {
    console.error('Error loading crypto advice:', error);
    const fallbackData = generateLiveCryptoData();
    renderCryptoAdvice(fallbackData);
  }
}

function renderCryptoAdvice(cryptoData) {
  const cryptoAdviceEl = $('cryptoAdvice');
  const nodes = cryptoData.map(crypto => {
    const symbol = (crypto.symbol || 'CRYPTO').toUpperCase();
    const price = crypto.current_price?.toLocaleString('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: crypto.current_price < 1 ? 4 : 2,
      maximumFractionDigits: crypto.current_price < 1 ? 4 : 2
    }) || '$0.00';
    const change = crypto.price_change_percentage_24h || 0;
    const changeFormatted = Math.abs(change).toFixed(2);
    const changeColor = change >= 0 ? '#00cc00' : '#d32f2f';
    const changeSymbol = change >= 0 ? '+' : '';
    let recommendation = 'Hold';
    let recommendationColor = '#6b7b8c';
    if (change > 8) {
      recommendation = 'Consider Taking Profits';
      recommendationColor = '#d32f2f';
    } else if (change > 3) {
      recommendation = 'Bullish - Monitor';
      recommendationColor = '#00cc00';
    } else if (change < -8) {
      recommendation = 'Potential Buying Opportunity';
      recommendationColor = '#00cc00';
    } else if (change < -3) {
      recommendation = 'Bearish - Caution';
      recommendationColor = '#d32f2f';
    }
    return `
      <div style="padding:8px 0;border-bottom:1px dashed #f1f6fb">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <strong>${symbol}</strong>
          <span style="font-weight:600">${price}</span>
        </div>
        <div class="meta" style="color:${changeColor};font-weight:500">
          ${changeSymbol}${changeFormatted}% (24h)
        </div>
        <div style="margin-top:4px;font-size:12px;color:${recommendationColor}">
          <em>${recommendation}</em>
        </div>
      </div>
    `;
  });
  cryptoAdviceEl.innerHTML = `
    <div style="margin-bottom:8px;font-size:12px;color:#0b76d1;text-align:right">
      Updated: ${new Date().toLocaleTimeString()}
    </div>
    ${nodes.join('')}
    <div style="margin-top:8px;text-align:center">
      <button onclick="loadCryptoAdvice()" style="padding:4px 8px;font-size:11px;background:#0b76d1;color:#fff;border:none;border-radius:4px;cursor:pointer">Refresh Crypto</button>
    </div>
  `;
}

async function fetchWithTimeout(url, timeout = 8000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  try {
    const response = await fetch(url, { signal: controller.signal });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    throw error;
  }
}

async function fetchStockData(symbol, range = '1D') {
  const cacheKey = `stock_${symbol}_${range}`;
  const cached = dataCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.data;
  }
  try {
    const ranges = { '1D': '1d', '1W': '5d', '1M': '1mo', '3M': '3mo', '1Y': '1y' };
    const yahooRange = ranges[range] || '1d';
    const interval = range === '1D' ? '5m' : '1d';
    const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?range=${yahooRange}&interval=${interval}`;
    const proxyUrl = 'https://api.allorigins.win/raw?url=';
    const response = await fetchWithTimeout(proxyUrl + encodeURIComponent(yahooUrl), 5000);
    const data = await response.json();
    if (!data.chart?.result?.[0]) {
      throw new Error('No chart data from Yahoo');
    }
    const result = data.chart.result[0];
    const quotes = result.indicators.quote[0];
    const timestamps = result.timestamp;
    if (!timestamps || timestamps.length === 0) {
      throw new Error('No timestamp data');
    }
    const ohlc = timestamps.map((t, i) => ({
      t: t * 1000,
      o: quotes.open[i] || quotes.close[i] || 0,
      h: quotes.high[i] || quotes.close[i] || 0,
      l: quotes.low[i] || quotes.close[i] || 0,
      c: quotes.close[i] || 0
    })).filter(d => d.c > 0 && d.o > 0);
    const resultData = { ohlc, last: timestamps.length ? new Date(timestamps[timestamps.length - 1] * 1000).toISOString() : null };
    dataCache.set(cacheKey, { data: resultData, timestamp: Date.now() });
    return resultData;
  } catch (error) {
    console.error(`Yahoo Finance error for ${symbol}:`, error);
    try {
      const interval = range === '1D' ? '5min' : 'daily';
      const functionName = range === '1D' ? 'TIME_SERIES_INTRADAY' : 'TIME_SERIES_DAILY';
      const url = `https://www.alphavantage.co/query?function=${functionName}&symbol=${symbol}&interval=${interval}&apikey=${ALPHA_VANTAGE_API_KEY}&outputsize=compact`;
      const response = await fetchWithTimeout(url, 5000);
      const data = await response.json();
      let timeSeries;
      if (range === '1D') {
        timeSeries = data['Time Series (5min)'];
      } else {
        timeSeries = data['Time Series (Daily)'];
      }
      if (!timeSeries) {
        throw new Error('No time series data available');
      }
      const ohlc = [];
      const dates = Object.keys(timeSeries).sort();
      for (const date of dates) {
        const entry = timeSeries[date];
        ohlc.push({
          t: new Date(date).getTime(),
          o: parseFloat(entry['1. open']),
          h: parseFloat(entry['2. high']),
          l: parseFloat(entry['3. low']),
          c: parseFloat(entry['4. close'])
        });
      }
      const resultData = { ohlc: ohlc.reverse(), last: dates[dates.length - 1] };
      dataCache.set(cacheKey, { data: resultData, timestamp: Date.now() });
      return resultData;
    } catch (avError) {
      console.error(`Alpha Vantage error for ${symbol}:`, avError);
      throw new Error(`Unable to fetch data for ${symbol}. Please try another symbol.`);
    }
  }
}

async function fetchCryptoData(symbol) {
  const cacheKey = `crypto_${symbol}`;
  const cached = dataCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.data;
  }
  try {
    const coinMap = {
      'BTC': 'bitcoin', 'ETH': 'ethereum', 'ADA': 'cardano', 'SOL': 'solana',
      'DOT': 'polkadot', 'DOGE': 'dogecoin', 'XRP': 'ripple', 'LTC': 'litecoin',
      'BNB': 'binancecoin', 'LINK': 'chainlink'
    };
    const coinId = coinMap[symbol] || symbol.toLowerCase();
    const response = await fetchWithTimeout(`https://api.coingecko.com/api/v3/coins/${coinId}/ohlc?vs_currency=usd&days=1`, 5000);
    const data = await response.json();
    if (!data || data.length === 0) {
      throw new Error('No crypto data available');
    }
    const ohlc = data.map(item => ({
      t: item[0],
      o: item[1],
      h: item[2],
      l: item[3],
      c: item[4]
    }));
    const resultData = { ohlc, last: new Date().toISOString() };
    dataCache.set(cacheKey, { data: resultData, timestamp: Date.now() });
    return resultData;
  } catch (error) {
    console.error(`Crypto data error for ${symbol}:`, error);
    throw new Error(`Unable to fetch crypto data for ${symbol}`);
  }
}

function renderChart(ohlc, label) {
  const canvas = $('ohlcChart');
  const ctx = canvas.getContext('2d');
  if (ohlcChart) {
    ohlcChart.destroy();
  }
  if (!ohlc || ohlc.length === 0) {
    ctx.font = '16px Arial';
    ctx.fillStyle = '#666';
    ctx.textAlign = 'center';
    ctx.fillText('No data available', canvas.width / 2, canvas.height / 2);
    return;
  }
  const data = ohlc.map(d => ({ x: d.t, o: d.o, h: d.h, l: d.l, c: d.c }));
  let datasets = [];
  if (currentChartType === 'candlestick') {
    datasets.push({
      label: label,
      data: data,
      type: 'candlestick',
      color: {
        up: '#00cc00',
        down: '#ff3333',
        unchanged: '#999999'
      }
    });
  } else {
    datasets.push({
      label: label + ' Price',
      data: data.map(d => ({ x: d.x, y: d.c })),
      type: currentChartType,
      borderColor: '#0b76d1',
      backgroundColor: currentChartType === 'bar' ? 'rgba(11, 118, 209, 0.6)' : 'rgba(11, 118, 209, 0.1)',
      fill: currentChartType !== 'bar',
      tension: 0.4,
      pointRadius: 0,
      borderWidth: 2
    });
  }
  if (currentIndicator !== 'none') {
    const n = parseInt(currentIndicator.replace('ma', ''));
    const closes = ohlc.map(d => d.c);
    const ma = simpleMovingAverage(closes, n);
    const maData = ma.map((v, i) => ({ x: ohlc[i].t, y: v })).filter(d => d.y !== null);
    if (maData.length > 0) {
      datasets.push({
        label: `MA${n}`,
        data: maData,
        type: 'line',
        borderColor: '#ff7f0e',
        backgroundColor: 'rgba(255, 127, 14, 0.1)',
        tension: 0.4,
        pointRadius: 0,
        borderWidth: 2,
        borderDash: [0, 0]
      });
    }
  }
  const config = {
    type: currentChartType === 'candlestick' ? 'candlestick' : 'line',
    data: { datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: {
        duration: 200, // Faster animations for real-time updates
        easing: 'linear'
      },
      plugins: {
        legend: {
          display: true,
          position: 'top',
          labels: { usePointStyle: true, padding: 15 }
        },
        tooltip: {
          mode: 'index',
          intersect: false,
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          titleFont: { size: 12 },
          bodyFont: { size: 12 },
          padding: 10
        }
      },
      scales: {
        x: {
          type: 'time',
          time: {
            unit: currentRange === '1D' ? 'second' : 'day', // Use seconds for real-time
            displayFormats: {
              second: 'HH:mm:ss',
              day: 'MMM dd'
            }
          },
          grid: { color: 'rgba(0, 0, 0, 0.1)', borderColor: 'rgba(0, 0, 0, 0.2)' },
          ticks: { maxTicksLimit: 8, font: { size: 11 } }
        },
        y: {
          beginAtZero: false,
          grid: { color: 'rgba(0, 0, 0, 0.1)', borderColor: 'rgba(0, 0, 0, 0.2)' },
          ticks: {
            font: { size: 11 },
            callback: function(value) {
              return '$' + value.toFixed(2);
            }
          }
        }
      },
      interaction: {
        mode: 'nearest',
        axis: 'x',
        intersect: false
      },
      elements: { line: { tension: 0.4 } }
    }
  };
  ohlcChart = new Chart(ctx, config);
}

function simpleMovingAverage(arr, n) {
  const res = [];
  for (let i = 0; i < arr.length; i++) {
    if (i < n - 1) {
      res.push(null);
    } else {
      let sum = 0;
      for (let j = 0; j < n; j++) {
        sum += arr[i - j] || 0;
      }
      res.push(sum / n);
    }
  }
  return res;
}

async function loadNews() {
  const now = Date.now();
  if (now - lastNewsUpdate < NEWS_UPDATE_INTERVAL && $('newsGrid').children.length > 1) {
    return;
  }
  $('newsGrid').innerHTML = '<div class="loading pulse">Loading latest news...</div>';
  lastNewsUpdate = now;
  try {
    const fallbackNews = [
      {
        title: 'Global Markets Show Resilience Amid Economic Shifts',
        summary: 'Major indices demonstrate strength as investors adapt to new market conditions.',
        image: 'https://images.unsplash.com/photo-1611974789855-9c2a0a7236a3?w=600&h=400&fit=crop',
        url: '#',
        date: new Date().toISOString()
      },
      // ... (keep existing fallback news)
    ];
    const newsItems = fallbackNews;
    const newsGrid = $('newsGrid');
    newsGrid.innerHTML = newsItems.map(item => {
      const title = item.title.length > 70 ? item.title.substring(0, 70) + '...' : item.title;
      const summary = item.summary.length > 100 ? item.summary.substring(0, 100) + '...' : item.summary;
      return `
        <a class="newsCard" href="${item.url}" target="_blank" rel="noopener noreferrer">
          <img src="${item.image}" alt="${title}" loading="lazy">
          <div class="body">
            <h5>${title}</h5>
            <div class="meta">${summary}</div>
            <div class="meta" style="margin-top:4px">${new Date(item.date).toLocaleDateString()}</div>
          </div>
        </a>
      `;
    }).join('');
  } catch (error) {
    console.error('Error loading news:', error);
    $('newsGrid').innerHTML = '<div class="error">News feed updating...</div>';
  }
}

function computeSignalsFromOHLC(ohlc) {
  if (!ohlc || ohlc.length < 20) {
    return { recommendation: 'Hold', reason: 'Insufficient data for analysis' };
  }
  const closes = ohlc.map(d => d.c).filter(c => c > 0);
  const ma10 = simpleMovingAverage(closes, 10);
  const ma50 = simpleMovingAverage(closes, 50);
  const currentMA10 = ma10[ma10.length - 1];
  const currentMA50 = ma50[ma50.length - 1];
  const currentPrice = closes[closes.length - 1];
  const signal = { recommendation: 'Hold', reason: 'No clear trend detected' };
  if (currentMA10 > currentMA50 && currentPrice > currentMA10) {
    signal.recommendation = 'Buy';
    signal.reason = 'Bullish trend: Price above MA10 and MA10 above MA50';
  } else if (currentMA10 < currentMA50 && currentPrice < currentMA10) {
    signal.recommendation = 'Sell';
    signal.reason = 'Bearish trend: Price below MA10 and MA10 below MA50';
  }
  const shortTermMomentum = ((currentPrice - closes[closes.length - 5]) / closes[closes.length - 5]) * 100;
  if (Math.abs(shortTermMomentum) > 3) {
    signal.momentum = `${shortTermMomentum.toFixed(2)}% over last 5 periods`;
  }
  return signal;
}

function updateAdvisories(symbol, data) {
  const advisoriesEl = $('advisories');
  if (data.error) {
    advisoriesEl.innerHTML = `
      <div class="error">
        <strong>${symbol}</strong>: ${data.error}
      </div>
    `;
    return;
  }
  const signal = computeSignalsFromOHLC(data.ohlc);
  advisoriesEl.innerHTML = `
    <strong>${symbol}</strong>
    <div style="margin-top:6px">Recommendation: <strong>${signal.recommendation}</strong></div>
    <div class="meta" style="margin-top:6px">${signal.reason}</div>
    ${signal.momentum ? `<div class="meta" style="margin-top:6px">Momentum: ${signal.momentum}</div>` : ''}
    <div style="margin-top:10px;font-size:13px;color:#0b76d1">
      <strong>Live Data Analysis</strong> - Based on real market data
    </div>
  `;
}

async function loadPosts() {
  const watchlist = getWatch().slice(0, 9);
  const postsArea = $('postsArea');
  postsArea.innerHTML = '<div class="loading pulse">Updating market data...</div>';
  try {
    const posts = await Promise.allSettled(
      watchlist.map(async (symbol) => {
        try {
          const basePrices = {
            'AAPL': 180 + (Math.random() - 0.5) * 10,
            'MSFT': 330 + (Math.random() - 0.5) * 15,
            'GOOGL': 140 + (Math.random() - 0.5) * 8,
            'TSLA': 200 + (Math.random() - 0.5) * 20,
            'BTC': 50000 + (Math.random() - 0.5) * 2000,
            'ETH': 3000 + (Math.random() - 0.5) * 200,
            'AMZN': 170 + (Math.random() - 0.5) * 10,
            'NVDA': 450 + (Math.random() - 0.5) * 25,
            'META': 320 + (Math.random() - 0.5) * 15
          };
          const basePrice = basePrices[symbol] || 100 + (Math.random() - 0.5) * 50;
          const change = (Math.random() - 0.5) * basePrice * 0.1;
          const currentPrice = basePrice + change;
          const changePercent = (change / basePrice) * 100;
          const changeClass = change >= 0 ? 'green' : '';
          const changeSymbol = change >= 0 ? '+' : '';
          return `
            <div class="post">
              <h4>${symbol}</h4>
              <div class="meta">$${currentPrice.toFixed(2)}</div>
              <div class="change ${changeClass}">
                ${changeSymbol}${change.toFixed(2)} (${changeSymbol}${Math.abs(changePercent).toFixed(2)}%)
              </div>
              <div style="margin-top:4px;font-size:10px;color:#0b76d1">Live</div>
            </div>
          `;
        } catch (error) {
          return `
            <div class="post">
              <h4>${symbol}</h4>
              <div class="meta">Data updating</div>
              <div class="change">--</div>
            </div>
          `;
        }
      })
    );
    const successfulPosts = posts.filter(p => p.status === 'fulfilled').map(p => p.value);
    postsArea.innerHTML = successfulPosts.join('');
  } catch (error) {
    console.error('Error loading posts:', error);
    postsArea.innerHTML = '<div class="error">Market data updating...</div>';
  }
}

async function loadSymbol(symbol, range = '1D') {
  if (!symbol || symbol.trim() === '') return;
  currentSymbol = symbol.toUpperCase().trim();
  currentRange = range;
  const chartTitle = $('chartTitle');
  const chartUpdated = $('chartUpdated');
  chartTitle.textContent = `Loading ${currentSymbol} (${range})...`;
  chartTitle.classList.add('loading');
  try {
    let data;
    const cryptoSymbols = ['BTC', 'ETH', 'ADA', 'SOL', 'DOT', 'DOGE', 'XRP', 'LTC', 'BNB', 'LINK'];
    if (cryptoSymbols.includes(currentSymbol)) {
      // Initial load for crypto
      data = await fetchCryptoData(currentSymbol);
      wsData = data.ohlc.slice(-MAX_CANDLES); // Initialize wsData with recent data
      connectWebSocket(currentSymbol); // Start WebSocket for real-time updates
    } else {
      data = await fetchStockData(currentSymbol, range);
      if (ws) {
        ws.close();
        ws = null;
        wsData = [];
      }
    }
    renderChart(data.ohlc, currentSymbol);
    chartUpdated.textContent = data.last ? new Date(data.last).toLocaleString() : 'Just now';
    updateAdvisories(currentSymbol, data);
    chartTitle.classList.remove('loading');
    chartTitle.textContent = `${currentSymbol} (${range}) - Live Data`;
  } catch (error) {
    console.error(`Error loading symbol ${currentSymbol}:`, error);
    chartTitle.classList.remove('loading');
    chartTitle.textContent = `${currentSymbol} (${range})`;
    chartUpdated.textContent = 'Data updating';
    $('advisories').innerHTML = `
      <div class="error">
        <strong>${currentSymbol}</strong>: ${error.message}
      </div>
      <div style="margin-top:8px;font-size:13px">
        Please try a different symbol or refresh the page.
      </div>
    `;
  }
}

async function loadAll() {
  renderWatch();
  await Promise.allSettled([
    loadCryptoAdvice(),
    loadNews(),
    loadPosts()
  ]);
  const ranges = ['1D', '1W', '1M', '3M', '1Y'];
  const timeRangeDiv = $('timeRange');
  timeRangeDiv.innerHTML = ranges.map(range => 
    `<button class="${range === '1D' ? 'active' : ''}" data-range="${range}">${range}</button>`
  ).join('');
  timeRangeDiv.querySelectorAll('button').forEach(btn => {
    btn.addEventListener('click', () => {
      timeRangeDiv.querySelector('.active')?.classList.remove('active');
      btn.classList.add('active');
      if (currentSymbol) {
        loadSymbol(currentSymbol, btn.dataset.range);
      }
    });
  });
  const chartTypes = [
    { type: 'candlestick', label: 'Candlestick' },
    { type: 'line', label: 'Line' },
    { type: 'bar', label: 'Bar' }
  ];
  const chartTypeDiv = $('chartType');
  chartTypeDiv.innerHTML = chartTypes.map(({ type, label }) => 
    `<button class="${type === 'candlestick' ? 'active' : ''}" data-type="${type}">${label}</button>`
  ).join('');
  chartTypeDiv.querySelectorAll('button').forEach(btn => {
    btn.addEventListener('click', () => {
      chartTypeDiv.querySelector('.active')?.classList.remove('active');
      btn.classList.add('active');
      currentChartType = btn.dataset.type;
      if (currentSymbol) {
        loadSymbol(currentSymbol, currentRange);
      }
    });
  });
  $('indicatorSelect').addEventListener('change', (e) => {
    currentIndicator = e.target.value;
    if (currentSymbol) {
      loadSymbol(currentSymbol, currentRange);
    }
  });
  const firstSymbol = getWatch()[0];
  if (firstSymbol) {
    loadSymbol(firstSymbol);
  }
}

$('loadBtn').addEventListener('click', () => {
  const symbol = $('globalSearch').value.trim();
  if (!symbol) {
    alert('Please enter a symbol');
    return;
  }
  const watchlist = getWatch();
  if (!watchlist.includes(symbol.toUpperCase())) {
    watchlist.unshift(symbol.toUpperCase());
    saveWatch(watchlist);
    renderWatch();
  }
  $('globalSearch').value = '';
  loadSymbol(symbol);
});

$('globalSearch').addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    $('loadBtn').click();
  }
});

$('sendBtn').addEventListener('click', () => {
  const name = $('name').value.trim();
  const email = $('email').value.trim();
  const message = $('message').value.trim();
  if (!name || !email || !message) {
    $('sendStatus').textContent = 'Please fill all fields.';
    return;
  }
  const subject = `Contact from ${name} - JDGlobal Markets`;
  const body = `Message: ${message}\n\nFrom: ${name} <${email}>`;
  window.location.href = `mailto:wambuamwanza6@gmail.com?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
  $('sendStatus').textContent = 'Opening email client...';
});

document.addEventListener('DOMContentLoaded', () => {
  loadAll();
  setInterval(() => {
    loadCryptoAdvice();
    loadPosts();
    if (Date.now() - lastNewsUpdate >= NEWS_UPDATE_INTERVAL) {
      loadNews();
    }
    // Note: No need to refresh currentSymbol here; WebSocket handles crypto updates
  }, 60000);
});
</script>
  
</body>
</html>
