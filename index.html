<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JDGlobal Markets</title>
  <meta name="description" content="Advanced finance dashboard with candlestick charts, indicators, trade advisories, crypto/forex signals and news thumbnails." />

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.1/dist/chartjs-chart-financial.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    html, body { height: 100%; }
    body { font-family: Inter, "Segoe UI", Roboto, Arial, sans-serif; background: #f6f8fb; color: #0b2240; margin: 0; padding: 18px; }
    #app { max-width: 1200px; margin: 0 auto; background: #fff; border-radius: 12px; padding: 18px; border: 1px solid #e6eef6; box-shadow: 0 12px 40px rgba(13,30,50,0.06); }
    .grid-main { display: grid; grid-template-columns: 320px 1fr; gap: 18px; margin-top: 16px; align-items: start; }
    @media (max-width: 700px) and (min-width: 421px) {
      .grid-main { grid-template-columns: 1fr 300px; gap: 12px; }
      .left { order: 2; }
      .mainSection { order: 1; }
      .chartWrap { height: 300px !important; }
      canvas#ohlcChart { height: 300px !important; }
    }
    @media (max-width: 420px) {
      .grid-main { grid-template-columns: minmax(140px, 1fr) 160px; gap: 8px; }
      .left { order: 2; }
      .mainSection { order: 1; }
      .chartWrap { height: 220px !important; }
      canvas#ohlcChart { height: 220px !important; }
      #app { overflow-x: auto; }
    }
    .card { background: #fff; border: 1px solid #eef6fb; border-radius: 10px; padding: 12px; }
    .chartWrap { height: 420px; position: relative; }
    .newsGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 12px; }
    .postsGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 12px; }
    .meta { color: #6b7b8c; }
    .loading { opacity: 0.6; }
    .pulse { animation: pulse 1.5s infinite; }
    @keyframes pulse { 0%{opacity:1} 50%{opacity:0.5} 100%{opacity:1} }
    canvas#ohlcChart { width: 100% !important; height: 400px !important; max-height: 400px; display: block; }
    .card-border { border: 1px solid #e6eef6; }
    .zoom-slider { width: 180px; }
    .ws-status { font-size: 0.75rem; color: #6b7b8c; }
    .ws-status.connected { color: #008800; }
    .ws-status.disconnected { color: #d32f2f; }
  </style>
</head>
<body>
  <div id="app">
    <div class="header flex items-center justify-between pb-3 border-b border-slate-100">
      <div class="flex items-center gap-4">
        <div class="w-14 h-14 rounded-xl bg-gradient-to-br from-sky-50 to-white flex items-center justify-center text-sky-600 font-extrabold text-lg shadow-sm">JDG</div>
        <div>
          <div class="text-lg font-semibold">JDGlobal Markets</div>
          <div class="text-sm meta">Real-time candlesticks, indicators, trade advisories & market news</div>
        </div>
      </div>
      <div class="flex items-center gap-3">
        <input id="globalSearch" placeholder="Symbol e.g. AAPL, TSLA, BTC, EURUSD" class="px-3 py-2 rounded-lg border card-border text-sm focus:outline-none" />
        <button id="loadBtn" class="px-3 py-2 rounded-lg bg-sky-600 text-white text-sm hover:bg-sky-700">Load</button>
      </div>
    </div>

<main class="grid-main">
  <aside class="left flex flex-col gap-4">
    <div class="card">
      <h4>Watchlist</h4>
      <div id="watchlist">Loading…</div>
      <div class="mt-2"><small class="meta">Tip: Add any global ticker (US/EU/Asia). For forex use EURUSD, for crypto use BTC, ETH etc.</small></div>
    </div>
    <div class="card">
      <h4>Trade Advisories</h4>
      <div id="advisories" class="advice">Loading advisories…</div>
    </div>
    <div class="card">
      <h4>Crypto Suggestions</h4>
      <div id="cryptoAdvice" class="advice">Loading crypto suggestions…</div>
    </div>
  </aside>
  <section class="mainSection">
    <div class="card chartCard">
      <div class="chartToolbar flex items-center gap-3 flex-wrap">
        <div><strong id="chartTitle">Select a symbol</strong></div>
        <div style="margin-left:auto" class="meta">Updated: <span id="chartUpdated">—</span></div>
        <div class="ws-status" id="wsStatus">WebSocket: Disconnected</div>
        <div id="timeRange" class="flex gap-2"></div>
        <div id="chartType" class="flex gap-2"></div>
        <select id="indicatorSelect" class="indicatorSelect ml-2 px-3 py-1 border rounded-lg card-border text-sm">
          <option value="none">MA: None</option>
          <option value="ma10">MA10</option>
          <option value="ma20">MA20</option>
          <option value="ma50">MA50</option>
        </select>
        <div class="ml-2 flex items-center gap-2">
          <label class="text-xs meta">Zoom</label>
          <input id="zoomSlider" class="zoom-slider" type="range" min="1" max="100" value="100" />
        </div>
      </div>
      <div class="chartWrap mt-3 rounded-lg overflow-hidden bg-slate-50 p-3">
        <canvas id="ohlcChart" aria-label="OHLC candlestick chart"></canvas>
      </div>
      <div style="margin-top:12px">
        <strong>Market News</strong>
        <div class="newsGrid" id="newsGrid">Loading news…</div>
      </div>
    </div>
    <div class="card mt-3">
      <h4 style="margin-top:0">Market Watch Posts</h4>
      <div class="postsGrid" id="postsArea">Loading posts…</div>
    </div>
  </section>
</main>

<footer class="mt-5 pt-4 border-t border-slate-100 flex flex-col md:flex-row items-start justify-between gap-4">
  <div>
    <div class="font-semibold">Market Pulse</div>
    <div class="meta">Real Markets Data and Analysis Dashboard by JDG Team</div>
  </div>
  <div class="contact card" style="width:360px">
    <strong>Contact</strong>
    <div class="meta">Messages will be prepared for: <strong>wambuamwanza6@gmail.com</strong></div>
    <input id="name" placeholder="Your name" class="mt-3 px-3 py-2 w-full rounded-lg border card-border text-sm" />
    <input id="email" placeholder="Your email" class="mt-2 px-3 py-2 w-full rounded-lg border card-border text-sm" />
    <textarea id="message" rows="4" placeholder="Your message" class="mt-2 px-3 py-2 w-full rounded-lg border card-border text-sm"></textarea>
    <button id="sendBtn" class="mt-3 px-4 py-2 rounded-lg bg-sky-600 text-white text-sm hover:bg-sky-700">Send</button>
    <div id="sendStatus" class="meta mt-2 text-sm"></div>
  </div>
</footer>  </div>

  <script>
    const ALPHA_VANTAGE_API_KEY = 'INZ7GV3B33PXV2QM';
    const COINCAP_API_KEY = '0afc0e9b884ade2e24eaa151b4559b4fb9ebf825b32771278ca1b4641c96aa1b'; // Replace with your CoinCap API key
    let lastNewsUpdate = 0;
    let lastCryptoUpdate = 0;
    const NEWS_UPDATE_INTERVAL = 300000;
    const CRYPTO_UPDATE_INTERVAL = 60000;
    let currentSymbol = '';
    let currentRange = '1D';
    let currentChartType = 'candlestick';
    let currentIndicator = 'none';
    let ohlcChart = null;
    let binanceWS = null;
    let currentBucket = null;
    let liveLineBuffer = [];
    let tradeBuffer = [];
    let lastUpdate = 0;
    const MAX_POINTS = 60;
    const LIVE_LINE_MAX = 300;
    const UPDATE_INTERVAL = 500;
    let useFallbackData = false;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 3;
    let heartbeatTimer = null;

    const $ = id => document.getElementById(id);
    const dataCache = new Map();
    const CACHE_DURATION = 60000;

    const BINANCE_STREAMS = {
      'BTC': 'btcusdt@trade',
      'ETH': 'ethusdt@trade',
      'ADA': 'adausdt@trade',
      'SOL': 'solusdt@trade',
      'DOT': 'dotusdt@trade',
      'DOGE': 'dogeusdt@trade',
      'XRP': 'xrpusdt@trade',
      'LTC': 'ltcusdt@trade',
      'BNB': 'bnbusdt@trade',
      'LINK': 'linkusdt@trade'
    };

    function getWatch() {
      try { return JSON.parse(localStorage.getItem('mp_watch') || '["AAPL","MSFT","GOOGL","TSLA","BTC"]'); }
      catch (e) { return ['AAPL','MSFT','GOOGL','TSLA','BTC']; }
    }
    function saveWatch(a) { localStorage.setItem('mp_watch', JSON.stringify(a)); }

    function updateWebSocketStatus(status, error = '') {
      const wsStatusEl = $('wsStatus');
      if (status === 'connected') {
        wsStatusEl.textContent = 'WebSocket: Connected';
        wsStatusEl.classList.remove('disconnected');
        wsStatusEl.classList.add('connected');
      } else if (status === 'disconnected') {
        wsStatusEl.textContent = `WebSocket: Disconnected${error ? ' - ' + error : ''}`;
        wsStatusEl.classList.remove('connected');
        wsStatusEl.classList.add('disconnected');
      } else {
        wsStatusEl.textContent = `WebSocket: ${status}${error ? ' - ' + error : ''}`;
        wsStatusEl.classList.remove('connected', 'disconnected');
      }
    }

    function connectBinance(symbol) {
      if (!symbol) return;
      
      if (binanceWS) {
        try { 
          binanceWS.close(); 
          clearInterval(heartbeatTimer);
        } catch(e) {}
      }

      const streamName = BINANCE_STREAMS[symbol];
      if (!streamName) {
        console.warn(`No Binance stream defined for ${symbol}`);
        updateWebSocketStatus('disconnected', 'Symbol not supported for live data');
        useFallbackData = true;
        return;
      }

      const url = `wss://stream.binance.com:9443/ws/${streamName}`;
      
      try {
        binanceWS = new WebSocket(url);
        updateWebSocketStatus('Connecting...');
        reconnectAttempts = 0;
      } catch (e) {
        console.error('WS connect error', e);
        updateWebSocketStatus('disconnected', 'Connection failed');
        useFallbackData = true;
        return;
      }

      binanceWS.onopen = () => {
        console.log(`Binance WS open for ${symbol} via ${streamName}`);
        updateWebSocketStatus('connected');
        useFallbackData = false;
        reconnectAttempts = 0;
        
        heartbeatTimer = setInterval(() => {
          if (binanceWS.readyState === WebSocket.OPEN) {
            binanceWS.send(JSON.stringify({ method: 'PING', id: Date.now() }));
          }
        }, 30000);
      };

      binanceWS.onmessage = (evt) => {
        try {
          const msg = JSON.parse(evt.data);
          if (msg.id && msg.result === null) return;
          
          if (msg.e === 'trade') {
            const price = parseFloat(msg.p);
            const ts = msg.E || Date.now();
            const volume = parseFloat(msg.q) || 1;
            
            const now = Date.now();
            const recentTrade = tradeBuffer.find(t => Math.abs(t.ts - now) < 100);
            if (!recentTrade) {
              tradeBuffer.push({ price, ts, volume });
            }
            
            if (symbol === 'BTC' || symbol === 'ETH') {
              if (Date.now() - lastUpdate >= 200) {
                processTradeBuffer();
              }
            } else if (Date.now() - lastUpdate >= UPDATE_INTERVAL) {
              processTradeBuffer();
            }
          }
        } catch (e) {
          console.error('WS message error', e);
        }
      };

      binanceWS.onerror = (err) => {
        console.error('Binance WS error', err);
        updateWebSocketStatus('disconnected', 'Connection error');
        useFallbackData = true;
      };

      binanceWS.onclose = (event) => {
        console.warn(`Binance WS closed: ${event.code} - ${event.reason}`);
        clearInterval(heartbeatTimer);
        
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          reconnectAttempts++;
          const delay = Math.min(2000 * Math.pow(2, reconnectAttempts), 15000);
          updateWebSocketStatus('disconnected', `Reconnecting in ${delay/1000}s...`);
          setTimeout(() => connectBinance(symbol), delay);
        } else {
          console.error('Max reconnect attempts reached.');
          updateWebSocketStatus('disconnected', 'Live data unavailable');
          useFallbackData = true;
        }
      };
    }

    function processTradeBuffer() {
      if (!tradeBuffer.length || !ohlcChart || !currentSymbol) return;
      
      const now = Date.now();
      lastUpdate = now;
      
      const timeWindow = 60000;
      const cutoffTime = now - timeWindow;

      const currentSecond = Math.floor(now / 1000) * 1000;
      const currentTrades = tradeBuffer.filter(t => t.ts >= currentSecond - 1000);
      
      if (currentTrades.length > 0) {
        const prices = currentTrades.map(t => t.price);
        const volumes = currentTrades.map(t => t.volume);
        const totalVolume = volumes.reduce((sum, v) => sum + v, 0);
        
        const avgPrice = currentTrades.reduce((sum, trade) => sum + (trade.price * trade.volume), 0) / totalVolume;
        const maxPrice = Math.max(...prices);
        const minPrice = Math.min(...prices);
        
        if (!currentBucket || currentBucket.t !== currentSecond) {
          const lastClose = currentBucket ? currentBucket.c : avgPrice;
          currentBucket = { 
            t: currentSecond, 
            o: lastClose, 
            h: maxPrice, 
            l: minPrice, 
            c: avgPrice,
            v: totalVolume
          };
        } else {
          currentBucket.h = Math.max(currentBucket.h, maxPrice);
          currentBucket.l = Math.min(currentBucket.l, minPrice);
          currentBucket.c = avgPrice;
          currentBucket.v += totalVolume;
        }
        
        updateChartWithBucket(currentBucket, cutoffTime);
      }
      
      tradeBuffer = tradeBuffer.filter(t => t.ts >= currentSecond - 1000);
    }

    let lastChartUpdate = 0;
    function updateChartWithBucket(bucket, cutoffTime) {
      if (!ohlcChart || Date.now() - lastChartUpdate < 100) return;
      lastChartUpdate = Date.now();
      
      const mainDataset = ohlcChart.data.datasets.find(d => 
        d.type === 'candlestick' || d.label === currentSymbol
      );
      
      if (!mainDataset) return;
      
      mainDataset.data = mainDataset.data.filter(d => d.x >= cutoffTime);
      
      const existingIndex = mainDataset.data.findIndex(d => d.x === bucket.t);
      if (existingIndex !== -1) {
        mainDataset.data[existingIndex] = {
          x: bucket.t,
          o: bucket.o,
          h: bucket.h, 
          l: bucket.l,
          c: bucket.c
        };
      } else {
        mainDataset.data.push({
          x: bucket.t,
          o: bucket.o,
          h: bucket.h,
          l: bucket.l, 
          c: bucket.c
        });
      }
      
      mainDataset.data.sort((a, b) => a.x - b.x);
      
      if (mainDataset.data.length > 0) {
        const times = mainDataset.data.map(d => d.x);
        ohlcChart.options.scales.x.min = Math.max(cutoffTime, Math.min(...times));
        ohlcChart.options.scales.x.max = Math.max(...times);
        updateYAxisScale(mainDataset.data);
      }
      
      updateLiveLine(bucket);
      
      $('chartTitle').textContent = `${currentSymbol} (${currentRange}) - Last: $${bucket.c.toFixed(currentSymbol === 'BTC' || currentSymbol === 'ETH' ? 2 : 4)}`;
      $('chartUpdated').textContent = new Date(bucket.t).toLocaleTimeString();
      
      requestAnimationFrame(() => {
        try { 
          ohlcChart.update('none'); 
          scheduleIndicatorRecalc();
        } catch (e) { 
          console.warn('Chart update error:', e);
        }
      });
    }

    function updateYAxisScale(data) {
      if (!data.length) return;
      
      const prices = data.flatMap(d => [d.o, d.h, d.l, d.c]).filter(p => p > 0);
      if (prices.length === 0) return;
      
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);
      const range = maxPrice - minPrice;
      
      const padding = range * 0.05 || minPrice * 0.01;
      ohlcChart.options.scales.y.min = Math.max(0, minPrice - padding);
      ohlcChart.options.scales.y.max = maxPrice + padding;
    }

    function updateLiveLine(bucket) {
      const liveLabel = `LIVE: ${currentSymbol}`;
      let liveDataset = ohlcChart.data.datasets.find(d => d.label === liveLabel);
      
      const currentTime = bucket.t;
      const existingIndex = liveLineBuffer.findIndex(p => p.x === currentTime);
      
      if (existingIndex !== -1) {
        liveLineBuffer[existingIndex] = { x: currentTime, y: bucket.c };
      } else {
        liveLineBuffer.push({ x: currentTime, y: bucket.c });
      }
      
      const oneMinuteAgo = currentTime - 60000;
      liveLineBuffer = liveLineBuffer.filter(p => p.x >= oneMinuteAgo);
      
      liveLineBuffer.sort((a, b) => a.x - b.x);
      
      const smoothedData = smoothLiveLineData(liveLineBuffer);
      
      if (!liveDataset) {
        ohlcChart.data.datasets.push({
          label: liveLabel,
          data: smoothedData,
          type: 'line',
          borderColor: 'rgba(255,77,77,0.8)',
          backgroundColor: 'rgba(255,77,77,0.1)',
          pointRadius: 0,
          borderWidth: 1.5,
          tension: 0.4,
          yAxisID: 'y'
        });
      } else {
        liveDataset.data = smoothedData;
      }
    }

    function smoothLiveLineData(data) {
      if (data.length < 3) return data;
      
      const smoothed = [];
      for (let i = 0; i < data.length; i++) {
        if (i === 0 || i === data.length - 1) {
          smoothed.push(data[i]);
        } else {
          const avgY = (data[i-1].y + data[i].y + data[i+1].y) / 3;
          smoothed.push({ x: data[i].x, y: avgY });
        }
      }
      return smoothed;
    }

    let _indicatorTimer = null;
    function scheduleIndicatorRecalc() {
      if (_indicatorTimer) clearTimeout(_indicatorTimer);
      _indicatorTimer = setTimeout(() => {
        _indicatorTimer = null;
        recalcIndicators();
      }, 500);
    }

    function recalcIndicators() {
      if (!ohlcChart || !currentIndicator || currentIndicator === 'none') return;
      
      const mainDataset = ohlcChart.data.datasets.find(d => 
        d.type === 'candlestick' || d.label === currentSymbol
      );
      
      if (!mainDataset || !mainDataset.data.length) return;
      
      const closes = mainDataset.data.map(d => d.c || d.y).filter(c => c > 0);
      if (closes.length < 10) return;

      const n = parseInt(currentIndicator.replace('ma', ''));
      const ma = simpleMovingAverage(closes, n);
      const maData = ma.map((v, i) => ({ 
        x: mainDataset.data[i].x, 
        y: v 
      })).filter(d => d.y !== null);
      
      const maLabel = `MA${n}`;
      let maDataset = ohlcChart.data.datasets.find(d => d.label === maLabel);
      
      if (maData.length > 0) {
        if (!maDataset) {
          ohlcChart.data.datasets.push({
            label: maLabel,
            data: maData,
            type: 'line',
            borderColor: '#ff7f0e',
            backgroundColor: 'rgba(255,127,14,0.1)',
            tension: 0.4,
            pointRadius: 0,
            borderWidth: 2
          });
        } else {
          maDataset.data = maData;
        }
      }
    }

    function simpleMovingAverage(arr, n) {
      const res = [];
      for (let i = 0; i < arr.length; i++) {
        if (i < n - 1) res.push(null);
        else { 
          let sum = 0; 
          for (let j = 0; j < n; j++) sum += arr[i - j] || 0; 
          res.push(sum / n); 
        }
      }
      return res;
    }

    function computeSignalsFromOHLC(ohlc) {
      if (!ohlc || ohlc.length < 20) return { recommendation: 'Hold', reason: 'Insufficient data for analysis' };
      const closes = ohlc.map(d => d.c).filter(c => c > 0);
      const ma10 = simpleMovingAverage(closes, 10);
      const ma50 = simpleMovingAverage(closes, 50);
      const currentMA10 = ma10[ma10.length - 1];
      const ma50Last = ma50[ma50.length - 1];
      const currentPrice = closes[closes.length - 1];
      const signal = { recommendation: 'Hold', reason: 'No clear trend detected' };
      if (currentMA10 > ma50Last && currentPrice > currentMA10) { signal.recommendation = 'Buy'; signal.reason = 'Bullish trend: Price above MA10 and MA10 above MA50'; }
      else if (currentMA10 < ma50Last && currentPrice < currentMA10) { signal.recommendation = 'Sell'; signal.reason = 'Bearish trend: Price below MA10 and MA10 below MA50'; }
      const shortTermMomentum = ((currentPrice - closes[closes.length - 5]) / closes[closes.length - 5]) * 100;
      if (Math.abs(shortTermMomentum) > 3) signal.momentum = `${shortTermMomentum.toFixed(2)}% over last 5 periods`;
      return signal;
    }

    function updateAdvisories(symbol, data) {
      const advisoriesEl = $('advisories');
      if (data.error) { 
        advisoriesEl.innerHTML = `<div class="text-red-600"><strong>${symbol}</strong>: ${data.error}</div>`; 
        return; 
      }
      const signal = computeSignalsFromOHLC(data.ohlc);
      advisoriesEl.innerHTML = `
        <strong>${symbol}</strong>
        <div class="mt-2">Recommendation: <strong>${signal.recommendation}</strong></div>
        <div class="meta mt-2">${signal.reason}</div>
        ${signal.momentum ? `<div class="meta mt-2">Momentum: ${signal.momentum}</div>` : ''}
        <div class="mt-3 text-sm text-sky-600"><strong>Live Data Analysis</strong> - Based on real market data</div>
      `;
    }

    function renderWatch() {
      const list = getWatch();
      const watchlistEl = $('watchlist');
      if (list.length === 0) { watchlistEl.textContent = 'No symbols.'; return; }
      watchlistEl.innerHTML = list.map(s => `
        <div class="flex justify-between items-center py-2 border-b border-dashed border-slate-100">
          <div><strong>${s}</strong></div>
          <button data-sym="${s}" class="viewBtn px-2 py-1 text-xs rounded bg-sky-600 text-white">View</button>
        </div>
      `).join('');
      document.querySelectorAll('.viewBtn').forEach(btn => { 
        btn.addEventListener('click', () => loadSymbol(btn.dataset.sym)); 
      });
    }

    async function fetchWithTimeout(url, timeout = 8000) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      try { 
        const response = await fetch(url, { signal: controller.signal }); 
        clearTimeout(timeoutId); 
        return response; 
      } catch (error) { 
        clearTimeout(timeoutId); 
        throw error; 
      }
    }

    async function fetchCryptoData(symbol) {
      const cacheKey = `crypto_${symbol}`;
      const cached = dataCache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < CACHE_DURATION) return cached.data;

      const coinMap = {
        'BTC': 'bitcoin',
        'ETH': 'ethereum',
        'ADA': 'cardano',
        'SOL': 'solana',
        'DOT': 'polkadot',
        'DOGE': 'dogecoin',
        'XRP': 'ripple',
        'LTC': 'litecoin',
        'BNB': 'binance-coin',
        'LINK': 'chainlink'
      };
      const coinId = coinMap[symbol];
      if (!coinId) throw new Error('Unsupported cryptocurrency');

      try {
        const response = await fetchWithTimeout(`https://api.coincap.io/v2/candles?exchange=binance&interval=m1&baseId=${coinId}&quoteId=tether`);
        const data = await response.json();
        if (!data.data) throw new Error('No data returned from CoinCap API');

        const ohlc = data.data.map(candle => ({
          t: new Date(candle.period).getTime(),
          o: parseFloat(candle.open),
          h: parseFloat(candle.high),
          l: parseFloat(candle.low),
          c: parseFloat(candle.close),
          v: parseFloat(candle.volume)
        }));

        const result = { ohlc, last: new Date().toISOString() };
        dataCache.set(cacheKey, { data: result, timestamp: Date.now() });
        return result;
      } catch (error) {
        console.error('Error fetching crypto data:', error);
        throw new Error(`Failed to fetch crypto data: ${error.message}`);
      }
    }

    async function fetchStockData(symbol, range = '1D') {
      const cacheKey = `stock_${symbol}_${range}`;
      const cached = dataCache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < CACHE_DURATION) return cached.data;

      let interval, timeSeriesKey;
      switch (range) {
        case '1D': interval = '1min'; timeSeriesKey = 'Time Series (1min)'; break;
        case '1W': interval = '5min'; timeSeriesKey = 'Time Series (5min)'; break;
        case '1M': interval = '60min'; timeSeriesKey = 'Time Series (60min)'; break;
        case '3M': interval = 'daily'; timeSeriesKey = 'Time Series (Daily)'; break;
        case '1Y': interval = 'daily'; timeSeriesKey = 'Time Series (Daily)'; break;
        default: throw new Error('Invalid range');
      }

      try {
        const response = await fetchWithTimeout(`https://www.alphavantage.co/query?function=TIME_SERIES_${interval.toUpperCase()}&symbol=${symbol}&apikey=${ALPHA_VANTAGE_API_KEY}`);
        const data = await response.json();
        if (data['Error Message']) throw new Error(data['Error Message']);
        if (!data[timeSeriesKey]) throw new Error('No time series data returned');

        const timeSeries = data[timeSeriesKey];
        const ohlc = Object.entries(timeSeries)
          .map(([time, values]) => ({
            t: new Date(time).getTime(),
            o: parseFloat(values['1. open']),
            h: parseFloat(values['2. high']),
            l: parseFloat(values['3. low']),
            c: parseFloat(values['4. close']),
            v: parseFloat(values['5. volume'])
          }))
          .sort((a, b) => a.t - b.t);

        if (range === '1Y') {
          ohlc.splice(0, ohlc.length - 365); // Limit to 1 year
        } else if (range === '3M') {
          ohlc.splice(0, ohlc.length - 90);
        }

        const result = { ohlc, last: new Date().toISOString() };
        dataCache.set(cacheKey, { data: result, timestamp: Date.now() });
        return result;
      } catch (error) {
        console.error('Error fetching stock data:', error);
        throw new Error(`Failed to fetch stock data: ${error.message}`);
      }
    }

    async function loadCryptoAdvice() {
      const now = Date.now();
      if (now - lastCryptoUpdate < CRYPTO_UPDATE_INTERVAL && $('cryptoAdvice').children.length > 1) return;
      lastCryptoUpdate = now;
      $('cryptoAdvice').innerHTML = '<div class="loading pulse text-sm">Loading live crypto data...</div>';

      try {
        const response = await fetchWithTimeout('https://api.coincap.io/v2/assets?limit=10');
        const data = await response.json();
        if (!data.data) throw new Error('No data returned from CoinCap API');

        renderCryptoAdvice(data.data);
      } catch (error) {
        console.error('Error loading crypto advice:', error);
        $('cryptoAdvice').innerHTML = `<div class="text-red-600">Error loading crypto data: ${error.message}</div>`;
      }
    }

    function renderCryptoAdvice(cryptoData) {
      const cryptoAdviceEl = $('cryptoAdvice');
      const nodes = cryptoData.map(crypto => {
        const symbol = (crypto.symbol || 'CRYPTO').toUpperCase();
        const price = parseFloat(crypto.priceUsd).toLocaleString('en-US', { 
          style: 'currency', 
          currency: 'USD', 
          minimumFractionDigits: parseFloat(crypto.priceUsd) < 1 ? 4 : 2, 
          maximumFractionDigits: parseFloat(crypto.priceUsd) < 1 ? 4 : 2 
        });
        const change = parseFloat(crypto.changePercent24Hr) || 0;
        const changeFormatted = Math.abs(change).toFixed(2);
        const changeColor = change >= 0 ? '#008800' : '#d32f2f';
        const changeSymbol = change >= 0 ? '+' : '';
        let recommendation = 'Hold', recommendationColor = '#6b7b8c';
        if (change > 8) { recommendation = 'Consider Taking Profits'; recommendationColor = '#d32f2f'; }
        else if (change > 3) { recommendation = 'Bullish - Monitor'; recommendationColor = '#008800'; }
        else if (change < -8) { recommendation = 'Potential Buying Opportunity'; recommendationColor = '#008800'; }
        else if (change < -3) { recommendation = 'Bearish - Caution'; recommendationColor = '#d32f2f'; }
        return `
          <div class="py-2 border-b border-slate-100">
            <div class="flex justify-between items-center">
              <strong>${symbol}</strong>
              <span class="font-semibold">${price}</span>
            </div>
            <div class="meta" style="color:${changeColor};font-weight:500">${changeSymbol}${changeFormatted}% (24h)</div>
            <div class="mt-1 text-xs" style="color:${recommendationColor}"><em>${recommendation}</em></div>
          </div>
        `;
      });
      cryptoAdviceEl.innerHTML = `
        <div class="text-xs text-sky-600 text-right mb-2">Updated: ${new Date().toLocaleTimeString()}</div>
        ${nodes.join('')}
        <div class="mt-3 text-center">
          <button onclick="loadCryptoAdvice()" class="px-3 py-1 text-xs rounded bg-sky-600 text-white">Refresh Crypto</button>
        </div>
      `;
    }

    async function loadNews() {
      const now = Date.now();
      if (now - lastNewsUpdate < NEWS_UPDATE_INTERVAL && $('newsGrid').children.length > 1) return;
      $('newsGrid').innerHTML = '<div class="loading pulse text-sm">Loading latest news...</div>';
      lastNewsUpdate = now;

      try {
        const response = await fetchWithTimeout(`https://www.alphavantage.co/query?function=NEWS_SENTIMENT&tickers=AAPL&apikey=${ALPHA_VANTAGE_API_KEY}`);
        const data = await response.json();
        if (!data.feed) throw new Error('No news data returned');

        const newsItems = data.feed.slice(0, 3).map(item => ({
          title: item.title,
          summary: item.summary,
          image: item.banner_image || 'https://images.unsplash.com/photo-1611974789855-9c2a0a7236a3?w=600&h=400&fit=crop',
          url: item.url,
          date: item.time_published
        }));

        const newsGrid = $('newsGrid');
        newsGrid.innerHTML = newsItems.map(item => {
          const title = item.title.length > 70 ? item.title.substring(0,70) + '...' : item.title;
          const summary = item.summary.length > 100 ? item.summary.substring(0,100) + '...' : item.summary;
          return `
            <a class="newsCard block bg-white rounded-lg overflow-hidden border card-border hover:shadow-md transition-transform" href="${item.url}" target="_blank" rel="noopener noreferrer">
              <img src="${item.image}" alt="${title}" loading="lazy" class="w-full h-36 object-cover">
              <div class="p-3">
                <h5 class="text-sm font-semibold mb-1">${title}</h5>
                <div class="meta text-xs">${summary}</div>
                <div class="meta text-xs mt-2">${new Date(item.date).toLocaleDateString()}</div>
              </div>
            </a>
          `;
        }).join('');
      } catch (error) {
        console.error('Error loading news:', error);
        $('newsGrid').innerHTML = `<div class="text-red-600">Error loading news: ${error.message}</div>`;
      }
    }

    async function loadPosts() {
      const watchlist = getWatch().slice(0,6);
      const postsArea = $('postsArea');
      postsArea.innerHTML = '<div class="loading pulse">Updating market data...</div>';

      try {
        const posts = await Promise.allSettled(watchlist.map(async (symbol) => {
          try {
            let price, changePercent;
            if (Object.keys(BINANCE_STREAMS).includes(symbol)) {
              const response = await fetchWithTimeout(`https://api.coincap.io/v2/assets/${symbol.toLowerCase()}`);
              const data = await response.json();
              price = parseFloat(data.data.priceUsd);
              changePercent = parseFloat(data.data.changePercent24Hr);
            } else {
              const response = await fetchWithTimeout(`https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${symbol}&apikey=${ALPHA_VANTAGE_API_KEY}`);
              const data = await response.json();
              if (!data['Global Quote']) throw new Error('No quote data');
              price = parseFloat(data['Global Quote']['05. price']);
              changePercent = parseFloat(data['Global Quote']['10. change percent'].replace('%', ''));
            }
            const change = price * (changePercent / 100);
            const changeClass = changePercent >= 0 ? 'text-emerald-600' : 'text-red-600';
            const changeSymbol = changePercent >= 0 ? '+' : '';
            return `
              <div class="post bg-white rounded-lg p-3 border card-border">
                <h4 class="text-sm font-semibold">${symbol}</h4>
                <div class="meta">$${price.toFixed(2)}</div>
                <div class="${changeClass} mt-1 text-sm">${changeSymbol}${change.toFixed(2)} (${changeSymbol}${Math.abs(changePercent).toFixed(2)}%)</div>
                <div class="text-xs text-sky-600 mt-2">Live</div>
              </div>
            `;
          } catch (error) {
            return `<div class="post bg-white rounded-lg p-3 border card-border"><h4 class="text-sm font-semibold">${symbol}</h4><div class="meta">Data updating</div><div class="change">--</div></div>`;
          }
        }));
        const successfulPosts = posts.filter(p => p.status === 'fulfilled').map(p => p.value);
        postsArea.innerHTML = successfulPosts.join('');
      } catch (error) {
        console.error('Error loading posts:', error);
        postsArea.innerHTML = `<div class="text-red-600">Error loading posts: ${error.message}</div>`;
      }
    }

    function renderChart(ohlc, label, isCrypto) {
      const canvas = $('ohlcChart');
      const ctx = canvas.getContext('2d');
      
      if (ohlcChart) {
        try { 
          ohlcChart.destroy(); 
        } catch(e) {}
      }
      
      tradeBuffer = [];
      liveLineBuffer = [];
      currentBucket = null;
      lastUpdate = 0;

      if (!ohlc || ohlc.length === 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = '16px Inter';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'center';
        ctx.fillText('No data available', canvas.width / 2, canvas.height / 2);
        return;
      }

      const now = Date.now();
      const timeWindow = 60000;
      const cutoffTime = now - timeWindow;
      
      let ohlcData = ohlc
        .map(d => ({ x: d.t, o: d.o, h: d.h, l: d.l, c: d.c }))
        .filter(d => d.x >= cutoffTime)
        .sort((a, b) => a.x - b.x);

      if (ohlcData.length === 0 && ohlc.length > 0) {
        const lastPoint = ohlc[ohlc.length - 1];
        ohlcData = [{ x: now - 30000, o: lastPoint.c, h: lastPoint.c, l: lastPoint.c, c: lastPoint.c }];
      }

      const datasets = [];
      if (currentChartType === 'candlestick') {
        datasets.push({
          label: label,
          data: ohlcData,
          type: 'candlestick',
          color: { up: '#008800', down: '#cc0000', unchanged: '#999999' }
        });
      } else {
        datasets.push({
          label: label + ' Price',
          data: ohlcData.map(d => ({ x: d.x, y: d.c })),
          type: currentChartType,
          borderColor: '#0b76d1',
          backgroundColor: currentChartType === 'bar' ? 'rgba(11,118,209,0.6)' : 'rgba(11,118,209,0.1)',
          fill: currentChartType !== 'bar',
          tension: 0.4,
          pointRadius: 0,
          borderWidth: 2
        });
      }

      const config = {
        type: currentChartType === 'candlestick' ? 'candlestick' : 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          plugins: {
            legend: { display: true, position: 'top', labels: { font: { size: 12, family: 'Inter' } } },
            tooltip: { 
              mode: 'index', 
              intersect: false, 
              backgroundColor: 'rgba(0,0,0,0.8)', 
              titleFont: { size: 12, family: 'Inter' }, 
              bodyFont: { size: 12, family: 'Inter' }, 
              padding: 10 
            },
            zoom: {
              pan: { enabled: true, mode: 'x' },
              zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' }
            }
          },
          scales: {
            x: { 
              type: 'time', 
              time: { 
                unit: currentRange === '1D' ? 'second' : 'day', 
                displayFormats: { 
                  second: 'HH:mm:ss', 
                  day: 'MMM dd' 
                } 
              }, 
              grid: { color: 'rgba(0,0,0,0.04)' }, 
              ticks: { maxTicksLimit: 8, font: { size: 10, family: 'Inter' } },
              min: ohlcData.length > 0 ? ohlcData[0].x : cutoffTime,
              max: ohlcData.length > 0 ? ohlcData[ohlcData.length - 1].x : now
            },
            y: { 
              beginAtZero: false, 
              grid: { color: 'rgba(0,0,0,0.04)' }, 
              ticks: { 
                callback: function(value) { 
                  return '$' + value.toFixed(value < 1 ? 4 : 2); 
                }, 
                font: { size: 10, family: 'Inter' } 
              }
            }
          }
        }
      };

      if (ohlcData.length > 0) {
        updateYAxisScale(ohlcData);
      }

      try { 
        ohlcChart = new Chart(ctx, config); 
      } catch (e) { 
        console.error('Chart render error:', e); 
      }
      
      applyZoomFromSlider();
      if (currentIndicator !== 'none') scheduleIndicatorRecalc();
    }

    async function loadSymbol(symbol, range = '1D') {
      if (!symbol || symbol.trim() === '') return;
      
      currentSymbol = symbol.toUpperCase().trim();
      currentRange = range;
      
      const chartTitle = $('chartTitle');
      const chartUpdated = $('chartUpdated');
      chartTitle.textContent = `Loading ${currentSymbol} (${range})...`;
      chartTitle.classList.add('loading');

      if (binanceWS) {
        try { 
          binanceWS.close(); 
          binanceWS = null;
        } catch(e) {}
      }
      
      tradeBuffer = [];
      currentBucket = null;
      liveLineBuffer = [];
      lastUpdate = 0;

      try {
        let data;
        const isCrypto = Object.keys(BINANCE_STREAMS).includes(currentSymbol);
        
        if (isCrypto) {
          data = await fetchCryptoData(currentSymbol);
          setTimeout(() => connectBinance(currentSymbol), 100);
        } else {
          data = await fetchStockData(currentSymbol, range);
          updateWebSocketStatus('disconnected', 'Real-time not available for stocks');
        }

        if (!data.ohlc || data.ohlc.length === 0) throw new Error('No OHLC data available');

        renderChart(data.ohlc, currentSymbol, isCrypto);
        chartUpdated.textContent = data.last ? new Date(data.last).toLocaleString() : 'Just now';
        updateAdvisories(currentSymbol, data);
        chartTitle.classList.remove('loading');
        
        const lastPrice = data.ohlc.length > 0 ? data.ohlc[data.ohlc.length - 1].c : 0;
        chartTitle.textContent = `${currentSymbol} (${range}) - Last: $${lastPrice.toFixed(currentSymbol === 'BTC' || currentSymbol === 'ETH' ? 2 : 4)}`;
      } catch (error) {
        console.error(`Error loading symbol ${currentSymbol}:`, error);
        chartTitle.classList.remove('loading');
        chartTitle.textContent = `${currentSymbol} (${range})`;
        chartUpdated.textContent = 'Data unavailable';
        $('advisories').innerHTML = `<div class="text-red-600"><strong>${currentSymbol}</strong>: ${error.message}</div><div class="mt-2 text-sm">Please try a different symbol or refresh the page.</div>`;
        
        if (ohlcChart) {
          ohlcChart.destroy();
          ohlcChart = null;
        }
        const canvas = $('ohlcChart');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = '16px Inter';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'center';
        ctx.fillText('No data available', canvas.width / 2, canvas.height / 2);
      }
    }

    function applyZoomFromSlider() {
      const slider = $('zoomSlider');
      if (!ohlcChart || !slider) return;
      const value = parseInt(slider.value, 10);
      const ds = ohlcChart.data.datasets && ohlcChart.data.datasets[0];
      if (!ds || !ds.data || ds.data.length === 0) return;
      const total = ds.data.length;
      const visible = Math.max(10, Math.round(total * (value / 100)));
      const lastIndex = total - 1;
      const firstIndex = Math.max(0, lastIndex - visible + 1);
      const minT = ds.data[firstIndex].x;
      const maxT = ds.data[lastIndex].x;
      try {
        ohlcChart.options.scales.x.min = minT;
        ohlcChart.options.scales.x.max = maxT;
        ohlcChart.update('none');
      } catch (e) {
        console.error('applyZoom error', e);
      }
    }

    async function loadAll() {
      renderWatch();
      await Promise.allSettled([loadCryptoAdvice(), loadNews(), loadPosts()]);
      const ranges = ['1D','1W','1M','3M','1Y'];
      const timeRangeDiv = $('timeRange');
      timeRangeDiv.innerHTML = ranges.map(range => `<button class="px-2 py-1 rounded text-xs ${range === '1D' ? 'bg-sky-600 text-white' : 'bg-slate-100'}" data-range="${range}">${range}</button>`).join('');
      timeRangeDiv.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', () => {
          timeRangeDiv.querySelector('.bg-sky-600')?.classList.remove('bg-sky-600','text-white');
          btn.classList.add('bg-sky-600','text-white');
          if (currentSymbol) loadSymbol(currentSymbol, btn.dataset.range);
        });
      });

      const chartTypes = [{ type: 'candlestick', label: 'Candlestick' }, { type: 'line', label: 'Line' }, { type: 'bar', label: 'Bar' }];
      const chartTypeDiv = $('chartType');
      chartTypeDiv.innerHTML = chartTypes.map(({type,label}) => `<button class="px-2 py-1 rounded text-xs ${type === 'candlestick' ? 'bg-slate-200' : 'bg-slate-100'}" data-type="${type}">${label}</button>`).join('');
      chartTypeDiv.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', () => {
          chartTypeDiv.querySelector('.bg-sky-600')?.classList.remove('bg-sky-600','text-white');
          chartTypeDiv.querySelector('.bg-slate-200')?.classList.remove('bg-slate-200');
          btn.classList.add('bg-slate-200');
          currentChartType = btn.dataset.type;
          if (currentSymbol) loadSymbol(currentSymbol, currentRange);
        });
      });

      $('indicatorSelect').addEventListener('change', (e) => {
        currentIndicator = e.target.value;
        if (currentSymbol) loadSymbol(currentSymbol, currentRange);
      });

      $('zoomSlider').value = 100;

      const firstSymbol = getWatch()[0];
      if (firstSymbol) loadSymbol(firstSymbol);
    }

    $('loadBtn').addEventListener('click', () => {
      const symbol = $('globalSearch').value.trim();
      if (!symbol) { alert('Please enter a symbol'); return; }
      const watchlist = getWatch();
      if (!watchlist.includes(symbol.toUpperCase())) { watchlist.unshift(symbol.toUpperCase()); saveWatch(watchlist); renderWatch(); }
      $('globalSearch').value = '';
      loadSymbol(symbol);
    });

    $('globalSearch').addEventListener('keypress', (e) => { if (e.key === 'Enter') $('loadBtn').click(); });

    $('sendBtn').addEventListener('click', () => {
      const name = $('name').value.trim(); 
      const email = $('email').value.trim(); 
      const message = $('message').value.trim();
      if (!name || !email || !message) { $('sendStatus').textContent = 'Please fill all fields.'; return; }
      const subject = `Contact from ${name} - JDGlobal Markets`;
      const body = `Message: ${message}\n\nFrom: ${name} <${email}>`;
      window.location.href = `mailto:wambuamwanza6@gmail.com?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
      $('sendStatus').textContent = 'Opening email client...';
    });

    document.addEventListener('input', (e) => {
      if (e.target && e.target.id === 'zoomSlider') applyZoomFromSlider();
    });

    document.addEventListener('DOMContentLoaded', () => {
      loadAll();
      setInterval(() => {
        loadCryptoAdvice(); 
        loadPosts();
        if (Date.now() - lastNewsUpdate >= NEWS_UPDATE_INTERVAL) loadNews();
      }, 60000);
    });
  </script>
</body>
</html>

