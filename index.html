<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JDGlobal Markets — Full Live Dashboard</title>
  <meta name="description" content="Advanced finance dashboard with candlestick charts, indicators, trade advisories, crypto/forex signals and news thumbnails." />

  <!-- Chart.js + Financial plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.0/dist/chartjs-chart-financial.min.js"></script>
  <!-- Zoom & Pan plugin for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

  <!-- Tailwind CDN for quick styling -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    html, body { height: 100%; }
    body { font-family: Inter, "Segoe UI", Roboto, Arial, sans-serif; background: #f6f8fb; color: #0b2240; margin: 0; padding: 18px; }
    #app { max-width: 1200px; margin: 0 auto; background: #fff; border-radius: 12px; padding: 18px; border: 1px solid #e6eef6; box-shadow: 0 12px 40px rgba(13,30,50,0.06); }
    .grid-main { display: grid; grid-template-columns: 320px 1fr; gap: 18px; margin-top: 16px; align-items: start; }
    .card { background: #fff; border: 1px solid #eef6fb; border-radius: 10px; padding: 12px; }
    .chartWrap { background:#f8fafc; border-radius:8px; padding:12px; }
    canvas { width: 100% !important; display: block; }
    .meta { color: #6b7b8c; }
    .loading { opacity: 0.6; }
    .pulse { animation: pulse 1.5s infinite; }
    @keyframes pulse { 0%{opacity:1} 50%{opacity:0.5} 100%{opacity:1} }
    .zoom-slider { width: 180px; }
    .small { font-size: 12px; }
    .btn { padding:6px 10px; border-radius:8px; background:#0b76d1; color:#fff; cursor:pointer; font-size:13px; }
    .btn-muted { background:#eef6fb; color:#0b2240; border:1px solid #e6eef6; }
    .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .subcharts { display:grid; grid-template-columns:1fr 1fr; gap: 12px; margin-top:12px; }
    @media (max-width:900px) { .grid-main { grid-template-columns: 1fr; } .subcharts{grid-template-columns:1fr;} }
  </style>
</head>
<body>
  <div id="app">
    <div class="header flex items-center justify-between pb-3 border-b border-slate-100">
      <div class="flex items-center gap-4">
        <div class="w-14 h-14 rounded-xl bg-gradient-to-br from-sky-50 to-white flex items-center justify-center text-sky-600 font-extrabold text-lg shadow-sm">JDG</div>
        <div>
          <div class="text-lg font-semibold">JDGlobal Markets</div>
          <div class="text-sm meta">Real-time candlesticks, indicators, trade advisories & market news</div>
        </div>
      </div>

      <div class="flex items-center gap-3">
        <input id="globalSearch" placeholder="Symbol e.g. AAPL, TSLA, BTC, EURUSD" class="px-3 py-2 rounded-lg border card-border text-sm focus:outline-none" />
        <button id="loadBtn" class="btn">Load</button>
      </div>
    </div>

    <main class="grid-main">
      <aside class="left flex flex-col gap-4">
        <div class="card">
          <h4>Watchlist</h4>
          <div id="watchlist">Loading…</div>
          <div class="mt-2"><small class="meta">Tip: For forex use EURUSD, for crypto use BTC,ETH; stocks use ticker symbols.</small></div>
        </div>

        <div class="card">
          <h4>Trade Advisories</h4>
          <div id="advisories" class="advice">Loading advisories…</div>
        </div>

        <div class="card">
          <h4>Crypto Suggestions</h4>
          <div id="cryptoAdvice" class="advice">Loading crypto suggestions…</div>
        </div>
      </aside>

      <section class="mainSection">
        <div class="card chartCard">
          <div class="chartToolbar flex items-center gap-3 flex-wrap">
            <div><strong id="chartTitle">Select a symbol</strong></div>
            <div style="margin-left:auto" class="meta">Updated: <span id="chartUpdated">—</span></div>

            <div id="timeRange" class="flex gap-2"></div>
            <div id="chartType" class="flex gap-2"></div>

            <select id="indicatorSelect" class="indicatorSelect ml-2 px-3 py-1 border rounded-lg card-border text-sm">
              <option value="none">MA: None</option>
              <option value="ma10">MA10</option>
              <option value="ma20">MA20</option>
              <option value="ma50">MA50</option>
            </select>

            <div class="ml-2 flex items-center gap-2">
              <label class="text-xs meta">Zoom</label>
              <input id="zoomSlider" class="zoom-slider" type="range" min="1" max="100" value="100" />
            </div>
          </div>

          <div class="chartWrap mt-3 rounded-lg overflow-hidden">
            <canvas id="ohlcChart" height="380" aria-label="OHLC candlestick chart"></canvas>
            <div class="subcharts">
              <canvas id="rsiChart" height="120" aria-label="RSI chart"></canvas>
              <canvas id="macdChart" height="120" aria-label="MACD chart"></canvas>
            </div>
          </div>

          <div style="margin-top:12px">
            <strong>Market News</strong>
            <div class="newsGrid grid grid-cols-3 gap-3 mt-2" id="newsGrid">Loading news…</div>
          </div>
        </div>

        <div class="card mt-3">
          <h4 style="margin-top:0">Market Watch Posts</h4>
          <div class="postsGrid grid grid-cols-3 gap-3" id="postsArea">Loading posts…</div>
        </div>
      </section>
    </main>

    <footer class="mt-5 pt-4 border-t border-slate-100 flex flex-col md:flex-row items-start justify-between gap-4">
      <div>
        <div class="font-semibold">Market Pulse</div>
        <div class="meta">Real Markets Data and Analysis Dashboard by JDG Team</div>
      </div>

      <div class="contact card" style="width:360px">
        <strong>Contact</strong>
        <div class="meta">Messages will be prepared for: <strong>wambuamwanza6@gmail.com</strong></div>
        <input id="name" placeholder="Your name" class="mt-3 px-3 py-2 w-full rounded-lg border card-border text-sm" />
        <input id="email" placeholder="Your email" class="mt-2 px-3 py-2 w-full rounded-lg border card-border text-sm" />
        <textarea id="message" rows="4" placeholder="Your message" class="mt-2 px-3 py-2 w-full rounded-lg border card-border text-sm"></textarea>
        <button id="sendBtn" class="mt-3 btn">Send</button>
        <div id="sendStatus" class="meta mt-2 text-sm"></div>
      </div>
    </footer>
  </div>

  <script>
  // ---------------------
  // Configuration & State
  // ---------------------
  const ALPHA_VANTAGE_API_KEY = 'INZ7GV3B33PXV2QM'; // replace in prod with server-side secret
  const DATA_CACHE_MS = 60 * 1000;
  const NEWS_UPDATE_INTERVAL = 5 * 60 * 1000;
  const cryptoSet = new Set(['BTC','ETH','BNB','ADA','SOL','DOT','DOGE','XRP','LTC','LINK']);
  let currentSymbol = 'BTC';
  let currentRange = '1D';
  let currentChartType = 'candlestick';
  let currentIndicator = 'none';
  let ohlcChart = null, rsiChart = null, macdChart = null;
  let binanceWS = null;
  let liveBuffer = []; // per-second live points {x:ts, y:price}
  const dataCache = new Map();

  const $ = id => document.getElementById(id);

  // ---------------------
  // Utilities
  // ---------------------
  async function fetchWithTimeout(url, timeout = 8000) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    try {
      const res = await fetch(url, { signal: controller.signal });
      clearTimeout(id);
      return res;
    } catch (e) {
      clearTimeout(id);
      throw e;
    }
  }

  function formatCurrency(v) {
    if (v === null || v === undefined || isNaN(v)) return '-';
    return v < 1 ? v.toFixed(4) : v.toFixed(2);
  }

  function msToDate(ms) { return new Date(ms); }

  // ---------------------
  // Indicators: SMA, RSI, MACD
  // ---------------------
  function sma(array, period) {
    const res = [];
    for (let i = 0; i < array.length; i++) {
      if (i < period - 1) { res.push(null); continue; }
      let sum = 0;
      for (let j = 0; j < period; j++) sum += array[i - j] || 0;
      res.push(sum / period);
    }
    return res;
  }

  function rsi(prices, period = 14) {
    if (!prices || prices.length < period + 1) return [];
    const deltas = [];
    for (let i = 1; i < prices.length; i++) deltas.push(prices[i] - prices[i - 1]);
    let seed = deltas.slice(0, period);
    let up = 0, down = 0;
    seed.forEach(d => { if (d >= 0) up += d; else down += Math.abs(d); });
    up /= period; down /= period;
    const rs = up / (down || 1e-9);
    const rsiArr = Array(period).fill(null);
    rsiArr.push(100 - 100 / (1 + rs));
    for (let i = period; i < deltas.length; i++) {
      const delta = deltas[i];
      let upval = delta > 0 ? delta : 0;
      let downval = delta < 0 ? Math.abs(delta) : 0;
      up = (up * (period - 1) + upval) / period;
      down = (down * (period - 1) + downval) / period;
      const rsLocal = up / (down || 1e-9);
      rsiArr.push(100 - 100 / (1 + rsLocal));
    }
    // align with prices: make length = prices.length, values shifted by 1 because deltas start at index1
    return [null].concat(rsiArr.slice(0, prices.length - 1));
  }

  function macd(prices, shortPeriod = 12, longPeriod = 26, signalPeriod = 9) {
    // EMA helper
    function ema(values, period) {
      const k = 2 / (period + 1);
      const res = [];
      let emaPrev = values.slice(0, period).reduce((a,b)=>a+b,0)/period;
      for (let i = 0; i < values.length; i++) {
        if (i < period - 1) { res.push(null); continue; }
        if (i === period -1) { res.push(emaPrev); continue; }
        emaPrev = values[i] * k + emaPrev * (1 - k);
        res.push(emaPrev);
      }
      return res;
    }
    const shortEMA = ema(prices, shortPeriod);
    const longEMA = ema(prices, longPeriod);
    const macdLine = prices.map((_, i) => {
      const s = shortEMA[i]; const l = longEMA[i];
      return (s !== null && l !== null) ? (s - l) : null;
    });
    const signalLine = ema(macdLine.map(v => v===null?0:v), signalPeriod).map(v => isFinite(v)?v:null);
    const hist = macdLine.map((m,i) => (m !== null && signalLine[i] !== null) ? (m - signalLine[i]) : null);
    return { macd: macdLine, signal: signalLine, hist };
  }

  // ---------------------
  // Chart creation helpers
  // ---------------------
  function createCharts() {
    const ctx = $('ohlcChart').getContext('2d');
    const rsiCtx = $('rsiChart').getContext('2d');
    const macdCtx = $('macdChart').getContext('2d');

    // destroy existing
    if (ohlcChart) try { ohlcChart.destroy(); } catch(e){};
    if (rsiChart) try { rsiChart.destroy(); } catch(e){};
    if (macdChart) try { macdChart.destroy(); } catch(e){};

    // Main Chart
    ohlcChart = new Chart(ctx, {
      type: currentChartType === 'candlestick' ? 'candlestick' : 'line',
      data: { datasets: [] },
      options: {
        animation: false,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true },
          tooltip: { mode: 'index', intersect: false }
        },
        scales: {
          x: { type: 'time', time: { unit: currentRange === '1D' ? 'hour' : 'day', displayFormats: { hour:'HH:mm', day:'MMM dd' } } },
          y: { beginAtZero: false }
        },
        plugins: {
          zoom: {
            pan: { enabled: true, mode: 'x' },
            zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' }
          }
        }
      }
    });

    // RSI Chart
    rsiChart = new Chart(rsiCtx, {
      type: 'line',
      data: { datasets: [{ label: 'RSI', data: [], borderColor: '#ff7f0e', pointRadius:0, borderWidth:1 }]},
      options: {
        animation: false,
        maintainAspectRatio: false,
        scales: { x: { type:'time' }, y: { min:0, max:100 } },
        plugins: { legend: { display: false } }
      }
    });

    // MACD Chart
    macdChart = new Chart(macdCtx, {
      type: 'bar',
      data: { datasets: [
        { label:'MACD Hist', data: [], backgroundColor: ctx => ctx.raw >= 0 ? 'rgba(0,200,0,0.5)' : 'rgba(200,0,0,0.5)' },
        { label:'MACD Line', type:'line', data: [], borderColor:'#1e90ff', pointRadius:0, borderWidth:1 },
        { label:'Signal Line', type:'line', data: [], borderColor:'#ff7f0e', pointRadius:0, borderWidth:1 }
      ]},
      options: {
        animation: false,
        maintainAspectRatio: false,
        scales: { x: { type:'time' }, y: {} },
        plugins: { legend: { display: false } }
      }
    });
  }

  // ---------------------
  // Data fetching
  // ---------------------
  async function fetchStockOHLC(symbol, range='1D') {
    const cacheKey = `stock_${symbol}_${range}`;
    const cached = dataCache.get(cacheKey);
    if (cached && Date.now() - cached.ts < DATA_CACHE_MS) return cached.val;

    try {
      const ranges = { '1D':'1d','1W':'5d','1M':'1mo','3M':'3mo','1Y':'1y' };
      const yahooRange = ranges[range] || '1d';
      const interval = range === '1D' ? '5m' : '1d';
      const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?range=${yahooRange}&interval=${interval}`;
      const proxy = 'https://api.allorigins.win/raw?url=';
      const res = await fetchWithTimeout(proxy + encodeURIComponent(yahooUrl), 6000);
      const json = await res.json();
      if (!json.chart?.result?.[0]) throw new Error('No data from Yahoo');

      const r = json.chart.result[0];
      const quotes = r.indicators.quote[0];
      const timestamps = r.timestamp;
      const ohlc = timestamps.map((t,i) => ({ t: t*1000, o: quotes.open[i], h: quotes.high[i], l: quotes.low[i], c: quotes.close[i] }))
                     .filter(d => d.c > 0 && d.o > 0);

      dataCache.set(cacheKey, { ts: Date.now(), val: { ohlc, last: ohlc.length ? ohlc[ohlc.length-1].t : null } });
      return { ohlc, last: ohlc.length ? ohlc[ohlc.length-1].t : null };
    } catch (err) {
      console.warn('Yahoo failed, trying Alpha Vantage', err);
      // Alpha Vantage fallback
      try {
        const functionName = range === '1D' ? 'TIME_SERIES_INTRADAY' : 'TIME_SERIES_DAILY';
        const interval = range === '1D' ? '5min' : 'daily';
        const url = `https://www.alphavantage.co/query?function=${functionName}&symbol=${symbol}&interval=${interval}&apikey=${ALPHA_VANTAGE_API_KEY}&outputsize=compact`;
        const res = await fetchWithTimeout(url, 7000);
        const json = await res.json();
        const timeseries = range === '1D' ? json['Time Series (5min)'] : json['Time Series (Daily)'];
        if (!timeseries) throw new Error('AlphaVantage no data');
        const dates = Object.keys(timeseries).sort();
        const ohlc = dates.map(d => {
          const e = timeseries[d];
          return { t: new Date(d).getTime(), o: parseFloat(e['1. open']), h: parseFloat(e['2. high']), l: parseFloat(e['3. low']), c: parseFloat(e['4. close']) };
        }).reverse();
        dataCache.set(cacheKey, { ts: Date.now(), val: { ohlc, last: ohlc.length ? ohlc[ohlc.length-1].t : null } });
        return { ohlc, last: ohlc.length ? ohlc[ohlc.length-1].t : null };
      } catch (avErr) {
        console.error('AlphaVantage failed', avErr);
        throw new Error('Unable to fetch stock data');
      }
    }
  }

  async function fetchCryptoOHLC(symbol) {
    const cacheKey = `crypto_${symbol}`;
    const cached = dataCache.get(cacheKey);
    if (cached && Date.now() - cached.ts < DATA_CACHE_MS) return cached.val;
    try {
      const coinMap = { 'BTC':'bitcoin','ETH':'ethereum','ADA':'cardano','SOL':'solana','DOT':'polkadot','DOGE':'dogecoin','XRP':'ripple','LTC':'litecoin','BNB':'binancecoin','LINK':'chainlink' };
      const coinId = coinMap[symbol] || symbol.toLowerCase();
      const res = await fetchWithTimeout(`https://api.coingecko.com/api/v3/coins/${coinId}/ohlc?vs_currency=usd&days=30`, 6000);
      const json = await res.json();
      if (!json || json.length == 0) throw new Error('No crypto OHLC');
      const ohlc = json.map(item => ({ t: item[0], o: item[1], h: item[2], l: item[3], c: item[4] }));
      dataCache.set(cacheKey, { ts: Date.now(), val: { ohlc, last: ohlc.length ? ohlc[ohlc.length-1].t : null } });
      return { ohlc, last: ohlc.length ? ohlc[ohlc.length-1].t : null };
    } catch (e) {
      console.error('CoinGecko failed', e);
      throw new Error('Unable to fetch crypto OHLC');
    }
  }

  // ---------------------
  // Render functions: convert fetched data into Chart datasets and render
  // ---------------------
  function buildDatasetsFromOHLC(ohlc, label) {
    // ohlc: [{t,o,h,l,c}, ...] where t in ms
    const baseDataset = (currentChartType === 'candlestick') ? {
      label,
      data: ohlc.map(d => ({ x: d.t, o: d.o, h: d.h, l: d.l, c: d.c })),
      type: 'candlestick',
      color: { up: '#00cc00', down: '#ff3333' }
    } : {
      label: label + ' Price',
      data: ohlc.map(d => ({ x: d.t, y: d.c })),
      type: 'line',
      borderColor: '#0b76d1',
      borderWidth: 1.6,
      pointRadius: 0,
      tension: 0.2
    };

    const datasets = [baseDataset];

    // indicator MA overlays
    if (currentIndicator !== 'none') {
      const n = parseInt(currentIndicator.replace('ma',''));
      const closes = ohlc.map(d => d.c);
      const maVals = sma(closes, n);
      const maData = maVals.map((v,i) => v === null ? null : { x: ohlc[i].t, y: v }).filter(Boolean);
      datasets.push({
        label: `MA${n}`,
        data: maData,
        type: 'line',
        borderColor: '#ff7f0e',
        pointRadius: 0,
        borderWidth: 1.4,
      });
    }

    return datasets;
  }

  function renderOHLCAndIndicators(ohlc, label) {
    // main chart
    const datasets = buildDatasetsFromOHLC(ohlc, label);
    ohlcChart.data.datasets = datasets;
    ohlcChart.update();

    // RSI
    const closes = ohlc.map(d => d.c);
    const rsiVals = rsi(closes, 14).map((v,i) => v === null ? null : { x: ohlc[i].t, y: v }).filter(Boolean);
    rsiChart.data.datasets[0].data = rsiVals;
    rsiChart.update();

    // MACD
    const mac = macd(closes);
    const macdPts = mac.macd.map((v,i) => v === null ? null : { x: ohlc[i].t, y: v }).filter(Boolean);
    const macSig = mac.signal.map((v,i) => v === null ? null : { x: ohlc[i].t, y: v }).filter(Boolean);
    const macHist = mac.hist.map((v,i) => v === null ? null : { x: ohlc[i].t, y: v }).filter(Boolean);

    // Align datasets for charts: hist (bar), macd (line), signal(line)
    macdChart.data.datasets[0].data = macHist;
    macdChart.data.datasets[1].data = macdPts;
    macdChart.data.datasets[2].data = macSig;
    macdChart.update();
  }

  // ---------------------
  // Live WebSocket handling (per-second updates)
  // ---------------------
  let liveSymbolLower = null;
  let liveBucket = null; // current second bucket for candlestick building

  function connectBinanceTradeStream(symbolUpper) {
    // symbolUpper e.g., 'BTC' or 'BTCUSDT' or 'BTC' we will use lower 'btcusdt'
    if (!symbolUpper) return;
    const s = symbolUpper.toLowerCase().replace('/','').replace('usd','usdt'); // attempts to map Tickers
    liveSymbolLower = s.includes('usdt') ? s : s + 'usdt';
    if (binanceWS) try { binanceWS.close(); } catch(e) {}
    const wsUrl = `wss://stream.binance.com:9443/ws/${liveSymbolLower}@trade`;
    try {
      binanceWS = new WebSocket(wsUrl);
    } catch (e) {
      console.error('WS create error', e);
      return;
    }

    binanceWS.onopen = () => {
      console.log('Binance WS open for', liveSymbolLower);
    };

    binanceWS.onmessage = (evt) => {
      try {
        const msg = JSON.parse(evt.data);
        // msg.p = price string, msg.T = tradeTime
        const price = parseFloat(msg.p);
        const ts = msg.T || Date.now();
        handleLiveTrade(price, ts);
      } catch (e) {
        // ignore
      }
    };

    binanceWS.onerror = (err) => {
      console.error('Binance WS error', err);
    };

    binanceWS.onclose = () => {
      console.warn('Binance WS closed; reconnecting in 2s');
      setTimeout(() => connectBinanceTradeStream(symbolUpper), 2000);
    };
  }

  function handleLiveTrade(price, timestamp) {
    // Build per-second candle for live overlay and push to liveBuffer (line)
    const tSec = Math.floor(timestamp / 1000) * 1000;
    if (!liveBucket || liveBucket.t !== tSec) {
      // new bucket
      const newBucket = { t: tSec, o: price, h: price, l: price, c: price };
      liveBucket = newBucket;
      // push to liveBuffer as a line point (latest price)
      liveBuffer.push({ x: timestamp, y: price });
      if (liveBuffer.length > 300) liveBuffer.shift();
      // add new candle to chart (if main dataset candlestick)
      if (currentChartType === 'candlestick') {
        // if underlying ohlcChart has a candlestick dataset, append
        const dsIndex = ohlcChart.data.datasets.findIndex(d => d.type === 'candlestick');
        if (dsIndex !== -1) {
          ohlcChart.data.datasets[dsIndex].data.push({ x: newBucket.t, o: newBucket.o, h: newBucket.h, l: newBucket.l, c: newBucket.c });
          // keep size reasonable
          if (ohlcChart.data.datasets[dsIndex].data.length > 500) ohlcChart.data.datasets[dsIndex].data.shift();
        }
      } else {
        // line chart: append last price point to dataset
        const ds = ohlcChart.data.datasets[0];
        ds.data.push({ x: timestamp, y: price });
        if (ds.data.length > 500) ds.data.shift();
      }
    } else {
      // update same bucket
      liveBucket.h = Math.max(liveBucket.h, price);
      liveBucket.l = Math.min(liveBucket.l, price);
      liveBucket.c = price;
      // update last candle on chart
      if (currentChartType === 'candlestick') {
        const dsIndex = ohlcChart.data.datasets.findIndex(d => d.type === 'candlestick');
        if (dsIndex !== -1) {
          const arr = ohlcChart.data.datasets[dsIndex].data;
          if (arr.length > 0) {
            arr[arr.length -1].h = Math.max(arr[arr.length -1].h, price);
            arr[arr.length -1].l = Math.min(arr[arr.length -1].l, price);
            arr[arr.length -1].c = price;
          }
        }
      } else {
        const ds = ohlcChart.data.datasets[0];
        if (ds.data.length > 0) {
          ds.data[ds.data.length -1].y = price;
        }
      }
      // push line buffer too
      liveBuffer.push({ x: timestamp, y: price });
      if (liveBuffer.length > 300) liveBuffer.shift();
    }

    // Update live overlay dataset (a line dataset labeled LIVE:)
    const liveLabel = `LIVE: ${currentSymbol}`;
    let liveIdx = ohlcChart.data.datasets.findIndex(d => d.label === liveLabel);
    const linePoints = liveBuffer.slice(-120).map(p => ({ x: p.x, y: p.y }));
    if (liveIdx === -1) {
      ohlcChart.data.datasets.push({
        label: liveLabel,
        data: linePoints,
        type: 'line',
        borderColor: '#ff4d4d',
        backgroundColor: 'rgba(255,77,77,0.06)',
        pointRadius: 0,
        borderWidth: 1.4,
        tension: 0.2,
        yAxisID: 'y'
      });
    } else {
      ohlcChart.data.datasets[liveIdx].data = linePoints;
    }

    // Update RSI and MACD incrementally based on last N closes if possible (fast approach)
    // For robust indicators, we recalc from main candlestick closes every N seconds (to keep correct)
    // Here: recalc every update but throttle to 400ms to avoid heavy CPU
    scheduleIndicatorsRecalc();

    // Update chart visuals but without animation to be smooth
    try {
      ohlcChart.update('none');
    } catch (e) { try { ohlcChart.update(); } catch(e2){} }
  }

  // throttled recalc
  let _indicatorScheduled = false;
  function scheduleIndicatorsRecalc() {
    if (_indicatorScheduled) return;
    _indicatorScheduled = true;
    setTimeout(() => {
      _indicatorScheduled = false;
      try {
        // extract closes from candlestick dataset (prefer candlestick dataset)
        let closes = [];
        const candleDs = ohlcChart.data.datasets.find(d => d.type === 'candlestick');
        if (candleDs && candleDs.data && candleDs.data.length) {
          closes = candleDs.data.map(d => d.c).filter(v=>v!=null);
        } else if (ohlcChart.data.datasets[0] && ohlcChart.data.datasets[0].data) {
          closes = ohlcChart.data.datasets[0].data.map(p => p.y).filter(v=>v!=null);
        }
        if (closes.length > 20) {
          const lastOHLC = (candleDs && candleDs.data) ? candleDs.data.slice(-500).map(d => ({t:d.x, o:d.o, h:d.h, l:d.l, c:d.c})) : closes.map((c,i)=>({t:Date.now()-((closes.length-i)*1000), o:c, h:c, l:c, c}));
          // recalc indicators using lastOHLC
          renderOHLCAndIndicators(lastOHLC, currentSymbol);
        }
      } catch (e) { console.error('indicator recalc err', e); }
    }, 400);
  }

  // ---------------------
  // High-level loadSymbol flow
  // ---------------------
  async function loadSymbol(symbol, range='1D') {
    if (!symbol) return;
    const sUpper = symbol.toUpperCase().replace('USD','').replace('/USDT','').replace('/USD','');
    currentSymbol = sUpper;
    currentRange = range;
    $('chartTitle').textContent = `Loading ${currentSymbol} (${currentRange})...`;
    $('chartTitle').classList.add('loading');

    // create charts
    createCharts();

    try {
      let dataObj;
      if (cryptoSet.has(currentSymbol)) {
        dataObj = await fetchCryptoOHLC(currentSymbol);
        // convert to proper ms timestamps (CoinGecko gives ms)
      } else {
        dataObj = await fetchStockOHLC(currentSymbol, currentRange);
      }
      const ohlc = dataObj.ohlc.map(d => ({ t: d.t, o: +d.o, h: +d.h, l: +d.l, c: +d.c }));
      // set currentChartType datasets and render w/ indicators
      const datasets = buildDatasetsFromOHLC(ohlc, currentSymbol);
      ohlcChart.data.datasets = datasets;
      ohlcChart.update();

      // clear liveBuffer and liveBucket so live overlay restarts
      liveBuffer = [];
      liveBucket = null;

      // connect websocket only for crypto (Binance WS provides trades)
      if (cryptoSet.has(currentSymbol)) {
        // map to symbol for binance subscription
        connectBinanceTradeStream(currentSymbol);
      } else {
        // no websocket for stocks; optionally could connect to a websocket provider
        if (binanceWS) try { binanceWS.close(); } catch(e){}
        binanceWS = null;
      }

      // initial indicators
      renderOHLCAndIndicators(ohlc, currentSymbol);

      // update advisories
      updateAdvisories(currentSymbol, { ohlc });

      $('chartUpdated').textContent = dataObj.last ? new Date(dataObj.last).toLocaleString() : 'Just now';
      $('chartTitle').classList.remove('loading');
      $('chartTitle').textContent = `${currentSymbol} (${currentRange}) - Live Data`;
    } catch (err) {
      console.error('loadSymbol error', err);
      $('chartTitle').classList.remove('loading');
      $('chartTitle').textContent = `${currentSymbol} (${currentRange})`;
      $('chartUpdated').textContent = 'Data updating';
      $('advisories').innerHTML = `<div class="text-red-600"><strong>${currentSymbol}</strong>: ${err.message}</div><div class="mt-2 text-sm">Please try a different symbol or refresh.</div>`;
    }
  }

  // ---------------------
  // Watchlist, Posts, Crypto Advice and News (UI fillers)
  // ---------------------
  function getWatch() {
    try { return JSON.parse(localStorage.getItem('mp_watch') || '["AAPL","MSFT","GOOGL","TSLA","BTC"]'); } catch(e){ return ['AAPL','MSFT','GOOGL','TSLA','BTC']; }
  }
  function saveWatch(a) { localStorage.setItem('mp_watch', JSON.stringify(a)); }

  function renderWatch() {
    const list = getWatch();
    const watchlistEl = $('watchlist');
    if (list.length === 0) { watchlistEl.textContent = 'No symbols.'; return; }
    watchlistEl.innerHTML = list.map(s => `
      <div class="flex justify-between items-center py-2 border-b border-dashed border-slate-100">
        <div><strong>${s}</strong></div>
        <div class="flex gap-2">
          <button data-sym="${s}" class="btn-muted viewBtn px-2 py-1 text-xs rounded">View</button>
          <button data-sym="${s}" class="btn btn-xs removeBtn px-2 py-1 text-xs rounded">Remove</button>
        </div>
      </div>
    `).join('');
    document.querySelectorAll('.viewBtn').forEach(btn => { btn.addEventListener('click', () => loadSymbol(btn.dataset.sym)); });
    document.querySelectorAll('.removeBtn').forEach(btn => { btn.addEventListener('click', () => {
      const sym = btn.dataset.sym;
      const arr = getWatch().filter(x=>x!==sym);
      saveWatch(arr); renderWatch();
    })});
  }

  async function loadPosts() {
    const watchlist = getWatch().slice(0,9);
    const postsArea = $('postsArea');
    postsArea.innerHTML = '<div class="loading pulse">Updating market data...</div>';
    try {
      const posts = watchlist.map(symbol => {
        const basePrices = { 'AAPL':180,'MSFT':330,'GOOGL':140,'TSLA':200,'BTC':50000,'ETH':3000,'AMZN':170,'NVDA':450,'META':320 };
        const base = basePrices[symbol] || 100 + (Math.random()-0.5)*50;
        const change = (Math.random()-0.5) * base * 0.03;
        const currentPrice = base + change;
        const changePercent = (change/base)*100;
        const changeClass = change >= 0 ? 'text-emerald-600' : 'text-red-600';
        const changeSymbol = change >= 0 ? '+' : '';
        return `<div class="post bg-white rounded-lg p-3 border card-border">
          <h4 class="text-sm font-semibold">${symbol}</h4>
          <div class="meta">$${currentPrice.toFixed(2)}</div>
          <div class="${changeClass} mt-1 text-sm">${changeSymbol}${change.toFixed(2)} (${changeSymbol}${Math.abs(changePercent).toFixed(2)}%)</div>
          <div class="text-xs text-sky-600 mt-2">Live</div>
        </div>`;
      });
      postsArea.innerHTML = posts.join('');
    } catch (e) {
      postsArea.innerHTML = '<div class="error text-sm">Market data updating...</div>';
    }
  }

  async function loadCryptoAdvice() {
    const el = $('cryptoAdvice');
    el.innerHTML = '<div class="loading pulse">Loading...</div>';
    try {
      // quick attempt: Binance ticker 24hr
      const res = await fetch('https://api.binance.com/api/v3/ticker/24hr');
      const json = await res.json();
      const top = ['BTCUSDT','ETHUSDT','BNBUSDT','ADAUSDT','SOLUSDT'];
      const filtered = json.filter(it => top.includes(it.symbol)).map(it => ({
        symbol: it.symbol.replace('USDT',''),
        price: parseFloat(it.lastPrice),
        pct: parseFloat(it.priceChangePercent)
      }));
      el.innerHTML = filtered.map(c => `<div class="py-2 border-b"><div class="flex justify-between"><strong>${c.symbol}</strong><span>$${formatCurrency(c.price)}</span></div><div class="meta">${c.pct.toFixed(2)}% (24h)</div></div>`).join('');
    } catch (e) {
      el.innerHTML = '<div class="meta">Crypto advice currently offline.</div>';
    }
  }

  async function loadNews() {
    const newsGrid = $('newsGrid');
    const fallback = [
      { title:'Global Markets Show Resilience Amid Economic Shifts', img:'https://images.unsplash.com/photo-1611974789855-9c2a0a7236a3?w=600&h=400&fit=crop' },
      { title:'Tech Stocks Lead Rally on AI Hopes', img:'https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=600&h=400&fit=crop' },
      { title:'Cryptocurrency Volatility Returns', img:'https://images.unsplash.com/photo-1621761191319-c6fb62004040?w=600&h=400&fit=crop' }
    ];
    newsGrid.innerHTML = fallback.map(n => `<div class="bg-white rounded-lg overflow-hidden border card-border p-2"><img src="${n.img}" class="w-full h-24 object-cover"/><div class="p-2"><strong class="text-sm">${n.title}</strong></div></div>`).join('');
  }

  // ---------------------
  // Advisories: simple signal using MA cross
  // ---------------------
  function computeSignalsFromOHLC(ohlc) {
    if (!ohlc || ohlc.length < 50) return { recommendation:'Hold', reason:'Insufficient data for analysis' };
    const closes = ohlc.map(d=>d.c);
    const ma10 = sma(closes, 10).filter(v=>v!=null);
    const ma50 = sma(closes, 50).filter(v=>v!=null);
    const last10 = ma10[ma10.length-1];
    const last50 = ma50[ma50.length-1];
    const currentPrice = closes[closes.length-1];
    let signal = { recommendation: 'Hold', reason: 'No clear trend' };
    if (last10 && last50 && currentPrice) {
      if (last10 > last50 && currentPrice > last10) signal = { recommendation:'Buy', reason:'Bullish: price > MA10 and MA10 > MA50' };
      else if (last10 < last50 && currentPrice < last10) signal = { recommendation:'Sell', reason:'Bearish: price < MA10 and MA10 < MA50' };
    }
    const momentum = ((currentPrice - closes[Math.max(0, closes.length-5)]) / closes[Math.max(0, closes.length-5)])*100;
    if (Math.abs(momentum) > 3) signal.momentum = `${momentum.toFixed(2)}% over last 5 periods`;
    return signal;
  }

  function updateAdvisories(symbol, data) {
    const el = $('advisories');
    try {
      const sig = computeSignalsFromOHLC(data.ohlc);
      el.innerHTML = `<strong>${symbol}</strong>
        <div class="mt-2">Recommendation: <strong>${sig.recommendation}</strong></div>
        <div class="meta mt-2">${sig.reason}</div>
        ${sig.momentum ? `<div class="meta mt-2">${sig.momentum}</div>` : ''}
        <div class="mt-3 small text-sky-600">Live Data Analysis</div>`;
    } catch (e) {
      el.innerHTML = `<div class="meta">Analysis unavailable</div>`;
    }
  }

  // ---------------------
  // UI wiring & initialization
  // ---------------------
  document.addEventListener('DOMContentLoaded', () => {
    // time ranges
    const ranges = ['1D','1W','1M','3M','1Y'];
    const timeRangeDiv = $('timeRange');
    timeRangeDiv.innerHTML = ranges.map(r => `<button class="px-2 py-1 rounded text-xs ${r==='1D'?'bg-sky-600 text-white':'bg-slate-100'}" data-range="${r}">${r}</button>`).join('');
    timeRangeDiv.querySelectorAll('button').forEach(btn => {
      btn.addEventListener('click', () => {
        timeRangeDiv.querySelector('.bg-sky-600')?.classList.remove('bg-sky-600','text-white');
        btn.classList.add('bg-sky-600','text-white');
        if (currentSymbol) loadSymbol(currentSymbol, btn.dataset.range);
      });
    });

    // chart types
    const chartTypes = [{ type:'candlestick', label:'Candlestick' },{ type:'line', label:'Line' }];
    const chartTypeDiv = $('chartType');
    chartTypeDiv.innerHTML = chartTypes.map(c=>`<button class="px-2 py-1 rounded text-xs ${c.type==='candlestick'?'bg-slate-200':'bg-slate-100'}" data-type="${c.type}">${c.label}</button>`).join('');
    chartTypeDiv.querySelectorAll('button').forEach(btn => {
      btn.addEventListener('click', () => {
        currentChartType = btn.dataset.type;
        chartTypeDiv.querySelector('.bg-slate-200')?.classList.remove('bg-slate-200');
        btn.classList.add('bg-slate-200');
        // re-render chart for current symbol
        loadSymbol(currentSymbol, currentRange);
      });
    });

    $('indicatorSelect').addEventListener('change', (e) => {
      currentIndicator = e.target.value;
      // re-render indicator overlay
      loadSymbol(currentSymbol, currentRange);
    });

    $('loadBtn').addEventListener('click', () => {
      const sym = $('globalSearch').value.trim();
      if (!sym) { alert('Please enter a symbol'); return; }
      const watch = getWatch();
      if (!watch.includes(sym.toUpperCase())) { watch.unshift(sym.toUpperCase()); saveWatch(watch); renderWatch(); }
      $('globalSearch').value = '';
      loadSymbol(sym.toUpperCase());
    });

    $('globalSearch').addEventListener('keypress', (e) => { if (e.key === 'Enter') $('loadBtn').click(); });

    $('sendBtn').addEventListener('click', () => {
      const name = $('name').value.trim(), email = $('email').value.trim(), message = $('message').value.trim();
      if (!name || !email || !message) { $('sendStatus').textContent = 'Please fill all fields.'; return; }
      const subject = `Contact from ${name} - JDGlobal Markets`;
      const body = `Message: ${message}\n\nFrom: ${name} <${email}>`;
      window.location.href = `mailto:wambuamwanza6@gmail.com?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
      $('sendStatus').textContent = 'Opening email client...';
    });

    // initial render
    renderWatch();
    loadCryptoAdvice();
    loadNews();
    loadPosts();

    // default symbol (first in watch)
    const first = getWatch()[0] || 'BTC';
    loadSymbol(first, '1D');

    // refresh some panels periodically
    setInterval(() => { loadCryptoAdvice(); loadPosts(); if (Date.now() - (window._lastNews||0) > NEWS_UPDATE_INTERVAL) { loadNews(); window._lastNews = Date.now(); } }, 60000);
  });
  </script>
</body>
</html>
